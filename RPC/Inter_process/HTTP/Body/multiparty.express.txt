
              
   MULTIPARTY  
              



ALTERNATIVES ==>              #MULTER is simpler, but MULTIPARTY:
                              #  - allow multipart/form-data without filename
                              #  - don't want to pollute tmpDir
                              #  - want to see hash
                              #  - streams

VERSION ==>                   #4.2.1
                              #"multipart/form-data" body parsing

FILES                         #{ VAR: FILE_ARR }
FILE                          #Part with filename
                              #STR[_ARR] (ARR if several with same filename)

FIELDS                        #{ VAR: FIELD_ARR }
FIELD                         #Part without filename
                              #OBJ_ARR:
                              #  - fieldName VAR
                              #  - originalFilename STR: in request body
                              #  - path PATH: in uploadDir
                              #  - headers OBJ:
                              #     - content-disposition STR
                              #     - content-type STR
                              #  - ws OSTREAM
                              #  - size NUM
                              #  - hash STR: only if OBJ.hash "sha1|md5" (in MULTIPARTY.Form() OBJ)

new MULTIPARTY.Form([OPTS])   #OPTS:
                              #  - encoding STR (def: 'utf8'): of the input
                              #  - maxFieldsSize NUM (def: 2MB): max size of each FIELD (emits error event otherwise)
                              #  - maxFields NUM (def: 1000): max numbers of keys in each FIELD (emits error)
                              #  - maxFilesSize NUM (def: Infinity): max size of each FILE (emits error)
                              #  - uploadDir (def: OS.tmpDir())
                              #  - autoFields|autoFiles BOOL
                              #     - def: true if FORM.on('file|field') called, or if FUNC() used with FORM.parse()
FORM                          #Is an OSTREAM
FORM.parse(REQ                #Parse REQ body as multipart/form-data and either:
[, FUNC(ERROR, FIELD, FILE)]) #  - if FUNC(): will populate uploadDir (should clean it at some point)
                              #  - otherwise: use FORM.on(...) to read files
FORM.on("part", FUNC(ISTREAM))#Emitted when receiving a FILE|FIELD member. ISTREAM also has:
                              #  - resume(): must be eventually called
                              #  - filename STR: only if FIELD
                              #  - name STR
                              #  - headers OBJ: content-disposition, content-type
                              #  - byteOffset|Count NUM
FORM.on
 ("file", FUNC(NAME, FILE))   #Emitted when receiving a FILE member.
FRM.on
 ("field", FUNC(NAME, FIELD)) #Emitted when receiving a FIELD member.
FORM.on("progress",
 FUNC(FORM.bytesReceived,
 FORM.bytesExpected))         #
FORM.on("close", FUNC())      #
FORM.on("error", FUNC(ERROR)) #

FORM.bytesReceived            #Currently parsed amount of bytes
FORM.bytesExpected            #Total amount of bytes, using Content-Length [C]
                              #0 if Transfer-Encoding [C]
                              #null if neither
FORM.totalFieldSize           #NUM
FORM.totalFieldCount          #NUM
FORM.totalFileSize            #NUM
FORM.flushing                 #
FORM.backpressure             #

ERRORS ==>                    #FORM.emit('error', ERROR)
                              #Sets FORM.error ERROR
                              #Cleanup files that were created
                              #Use HTTP-ERRORS (see its doc):
                              #  - 415: missing Content-Type [C]

                              #  - 400 (ERROR.type "request.aborted") if client aborted the request
                              #  - 400 (ERROR.type "request.size.invalid") if Content-Length [C] does not match
                              #  - 400 (ERROR.type "entity.parse.failed") if parsing failed
                              #  - 403 on wrong verify()
                              #  - 413 (ERROR.type "entity.too.large") if above OPTS.limit
                              #  - 413 (ERROR.type "parameters.too.many") if above OPTS.parameterLimit
                              #  - 415 (ERROR.type "encoding.unsupported") on unsupported ENCODING,
                              #    or if OPTS.inflate false and should decompress, or if unsupported encoding
                              #  - 415 (ERROR.type "charset.unsupported") on unsupported charset
