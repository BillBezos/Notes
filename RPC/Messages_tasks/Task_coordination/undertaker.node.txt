
              
   UNDERTAKER  
              



ALTERNATIVES ==>                  #  - undertaker (prefered)
                                  #  - orchestrator: not maintained and less features

VERSION ==>                       #1.2.0
                                  #Run functions in a specific order in series|parallel according to their dependencies

TASK                              #Either:
                                  #  - 'TASK' registered with UNDERTAKER.task()
                                  #  - FUNC

new Undertaker()                  #

UNDERTAKER.task('TASK', TASK)???
UNDERTAKER.task('TASK', FUNC)     #Register a TASK
                                  #FUNC uses async-done (see its doc), i.e. can be async with PROMISE|callback|STREAM|EVENTEMITTER|CHILD_PROCESS|OBSERVABLE
UNDERTAKER.task(FUNC)             #Same but using FUNC.name|displayName
UNDERTAKER.task('TASK')
 ->FUNC|undefined                 #FUNC is wrapped. To get original one, use FUNC.unwrap()->FUNC

UNDERTAKER.series|parallel        #Returns a FUNC2 that fires all FUNC serially or in parallel
 (TASK_ARR)->FUNC2                #To declare task dependencies, use UNDERTAKER.task('TASK', UNDERTAKER.series|parallel(...))

UNDERTAKER.tree([OPTS])->OBJ      #Returns tree of dependencies, as OBJ???
                                  #OPTS: deep BOOL (def: false)

UNDERTAKER.lastRun(TASK[, NUM])   #Returns last time TASK was run
 ->DATE_NUM|undefined             #NUM is rounding (def: 0, i.e. ms rounding) (can also use UNDERTAKER_TIME_RESOLUTION envvar)
                                  #Will return undefined if not run or last run was an error.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           REGISTRY            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REGISTRY                          #Store tasks
REGISTRY.init(UNDERTAKER)         #Can e.g. be used to add pre-defined tasks
REGISTRY.get('TASK')
 ->FUNC|undefined                 #
REGISTRY.set('TASK', FUNC)->FUNC  #
REGISTRY.tasks()->{TASK: FUNC,...}#

new Undertaker(REGISTRY)          #Specify a custom REGISTRY
UNDERTAKER.registry()->REGISTRY   #
UNDERTAKER.registry(REGISTRY)     #Replaces REGISTRY and transfer tasks, i.e. effectively merge two REGISTRY

UNDERTAKER-REGISTRY              ##Default REGISTRY
                                 ##Only stores tasks in an OBJ.




VERSION ==>                      ##2.0.0
                                 ##Async map in parallel|series

NOW-AND-LATER.mapSeries(OBJ|ARR,
 FUNC(VAL,KEY,FUNC2(ERROR, VAL2))##Async map over OBJ|ARR keys|values
 [, HOOKS]                       ##Is performed serially.
 [, FUNC3(ERROR, VAL2_ARR)])     ##If any FUNC2() is called with ERROR, series stops.

NOW-AND-LATER.map(...)           ##Same but in parallel

HOOKS                            ##OBJ with hook functions:
                                 ##  - create(VAL, KEY)->OBJ2: called before each iteration
                                 ##  - before(OBJ2): called before each iteration
                                 ##  - after(VAL2, OBJ2): called after each successful iteration
                                 ##  - error(ERROR, OBJ2): called after each error iteration



VERSION ==>                      ##1.2.0
                                 ##Map of async functions in parallel|series
                                 ##Uses NOW-AND-LATER under the hood

BACH-SERIES.series
 (FUNC[_ARR],...[, HOOKS])       ##Returns FUNC2 that fires each FUNC() async and serially
 ->FUNC2(FUNC3(ERROR, VAL2_ARR)) ##Uses async-done (see its doc), i.e. FUNC can be async with PROMISE|callback|STREAM|EVENTEMITTER|CHILD_PROCESS|OBSERVABLE

BACH-SERIES.parallel(...)        ##Same but in parallel

BACH-SERIES.settleSeries|Parallel##Same but with FUNC3(ERROR_ARR, VAL2_ARR)
 (...)                           ##I.e. does not stop at first error.

