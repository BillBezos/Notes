
              
   UNDERTAKER  
              



ALTERNATIVES ==>                  #  - undertaker (prefered)
                                  #  - orchestrator: not maintained and less features

VERSION ==>                       #1.2.0
                                  #Run functions in a specific order in series|parallel according to their dependencies

TASK                              #Either:
                                  #  - 'TASK' registered with UNDERTAKER.task()
                                  #  - FUNC

new Undertaker()                  #

UNDERTAKER.task('TASK', TASK)???
UNDERTAKER.task('TASK', FUNC)     #Register a TASK
                                  #FUNC uses async-done (see its doc), i.e. can be async by:
                                  #  - returning PROMISE
                                  #  - using parameter FUNC2([ERROR])
                                  #  - returning STREAM|EVENTEMITTER
                                  #  - returning CHILD_PROCESS
                                  #  - returning OBSERVABLE
UNDERTAKER.task(FUNC)             #Same but using FUNC.name|displayName
UNDERTAKER.task('TASK')
 ->FUNC|undefined                 #FUNC is wrapped. To get original one, use FUNC.unwrap()->FUNC

UNDERTAKER.series|parallel        #Returns a FUNC2 that fires all FUNC serially or in parallel
 (TASK_ARR)->FUNC2                #To declare task dependencies, use UNDERTAKER.task('TASK', UNDERTAKER.series|parallel(...))

UNDERTAKER.tree([OPTS])->OBJ      #Returns tree of dependencies, as OBJ???
                                  #OPTS: deep BOOL (def: false)

UNDERTAKER.lastRun(TASK[, NUM])   #Returns last time TASK was run
 ->DATE_NUM|undefined             #NUM is rounding (def: 0, i.e. ms rounding) (can also use UNDERTAKER_TIME_RESOLUTION envvar)
                                  #Will return undefined if not run or last run was an error.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           REGISTRY            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REGISTRY                          #Store tasks
REGISTRY.init(UNDERTAKER)         #Can e.g. be used to add pre-defined tasks
REGISTRY.get('TASK')
 ->FUNC|undefined                 #
REGISTRY.set('TASK', FUNC)->FUNC  #
REGISTRY.tasks()->{TASK: FUNC,...}#

new Undertaker(REGISTRY)          #Specify a custom REGISTRY
UNDERTAKER.registry()->REGISTRY   #
UNDERTAKER.registry(REGISTRY)     #Replaces REGISTRY and transfer tasks, i.e. effectively merge two REGISTRY

UNDERTAKER-REGISTRY              ##Default REGISTRY
                                 ##Only stores tasks in an OBJ.


BACH-SERIES.series(FUNC[_ARR],...[, HOOKS])



VERSION ==>                      ##2.0.0
                                 ##Async map in parallel|series

NOW-AND-LATER.mapSeries(OBJ|ARR, ##Async map over OBJ|ARR keys|values
 FUNC(VAL,KEY,FUNC2(ERROR, VAL2))##Is performed serially.
 [, HOOKS]                       ##If any FUNC2() is called with ERROR, series stops.
 [, FUNC3(ERROR, VAL2_ARR)])     ##HOOKS is an OBJ:
                                 ##  - create(VAL, KEY)->OBJ2: called before each iteration
                                 ##  - before(OBJ2): called before each iteration
                                 ##  - after(VAL2, OBJ2): called after each successful iteration
                                 ##  - error(ERROR, OBJ2): called after each error iteration
NOW-AND-LATER.map(...)           ##Same but in parallel
