New reporters:
  - 'min' (def):
     - make ERROR.request|response plugin-specific
        - including colorization
     - remember most ERROR.* might not exist
     - make titles a plugin.title()??

Everything indented 2 spaces

x ERROR.message (red)
  TASK.title (colorized)
  ----------------------
  Property: ERROR.property

  Difference: (expected + actual)
  DIFF (colorized)

  Value: ERROR.actual (colorized)

  JSON schema: ERROR.schema (YAML, colorized)

  Request: ERROR.task.request (colorized) (prettified???)

  Response: ERROR.task.response (colorized) (prettified???)

x ...

passed:  NUM (green)
failed:  NUM (red)
skipped: NUM (gray) (only if any skipped)

ERROR.property of validate plugin is wrong (it should be validate.* not call.*)

Using reporter during start|end handers???

null:
  - null filtering out should happen at beginning of stringify plugin
  - add todo comment that "invalid" null logic should use { allOf: { not: { enum: null } } } when supported yet by json-schema-faker
  - all the following is already done. Just need to double check it:
      - param with `null` top-level value are filtered out
      - 'invalid' will remove 'null' from 'type' to make sure it is always generated
      - validate.body|headers.* with type 'null' will check === undefined, with no type "null" check !== undefined, with type "null" or others will check neither
      - response body "" becomes undefined during 'parse' plugin

Requiredness:
  - goal:
     - task.call.* should always be generated (deeply)
     - task.random.* should always be generated (deeply)
     - config.spec params should be generated according to param.required (top-level) and objectSchema.required (deeply)
  - problem:
     - spec params are deeply merged to task.call|random.*
  - how json-schema-faker works:
     - non-required properties: always|never according to option
     - required properties: always
     - patternProperties: always|never according to option
     - additionalProperties: only if minProperties
  - to consider:
     - empty object means reuse the spec
  - solution:
     - param.isRandom true: keep it as is
     - param.namespace "call|random|spec":
         - used to avoid merging between params of different namespace
     - param.required STR:
         - "full" (def):
             - task.call|random.*
             - optionalsProbability 1 with json-schema-faker
         - "partial":
             - spec param with required true
         - "optional"
             - spec param with required false
             - during merging, ignored if no param with same name|location but with required "full|partial" exists
                 - i.e. empty object reuse the spec
         - "partial|optional":
             - generated twice: "value" with optionalsProbability 0, "fullValue" with 1
             - when deep merged with "firstValue":
                 - for each recursion depth if:
                     - firstValue defined, value defined, deep merge firstValue and fullValue
                     - firstValue defined, value undefined, fullValue defined, deep merge firstValue and fullValue
                     - firstValue defined, value undefined, fullValue undefined, use firstValue
                     - firstValue undefined, use either value or fullValue
     - param merge only happens once after random generation, at beginning of stringify plugin
          - spec start handler adds to task.call.params, and so does random start handler
     - no need for undefined filtering anymore in random plugin
     - no need for required filtering in random plugin anymore

Skip/only:
  - should be a plugin
  - skip has priority over only
  - TASK.skip|only BOOL
  - CONF.skip|only "GLOB"[_ARR]
     - same as setting TASK.skip|only true on test whose key matches GLOB
     - not applied on TASKs where TASK.skip|only is explicitely false
  - "only" filters tasks out in beginning of start handlers
     - for performance
     - i.e. not reported
  - "skip" throws at beginning of each task, setting ERROR.skipped true
     - TAP reporter mark this as # SKIP
        - also present in end TAP output as # skip: NUM
     - i.e. task is still going through start handlers, e.g. validated
  - remove "dry" plugin, redundant with config.skip "*"

CLI options:
  - get all possible plugins using readdir list from plugins dir
      - add TODO to use node_modules instead
  - then require all plugins
  - build CLI options descriptions using PLUGIN.conf.general|task.description|default|schema.type|required|others? and PLUGIN.conf.examples
  - think of type "object" and "array"
  - check code from autoserver
  - default value should be appended to description instead of using yargs.default()
  - task options should be added as an option under task category but throw error during parsing. An explanation at beginning of --help should explain how task options work
  - should work with dynamic options like config.report.options.* but still be strict enough to validate typos

Enforce plugins separation by filter conf|task.* input and output to plugin.[optional]dependencies

Should add headers added by default by node-fetch to returnValue.request.*???

Support collectionFormat `multi` on query parameter serialization

Fix README.md

Fix api-service

Fix this doc with new names (e.g. "task" instead of test)

config.maxParallel:
  - max number of tasks at once
  - def 100
  - buffered in the beginning of runTask, i.e.:
     - depReqs count as one task
     - repeated tasks each count as one task

CPU parallelism:
  - run tasks in several worker processes
  - only for 'task' handlers
     - 'start', 'complete' and 'end' are run in master process
        - we need 'complete' handlers in same process because they are stateful,
          e.g. tasks ordering, TAP index incrementing, progress bar, etc.
  - check async to_learn for inspiration
  - should respect maxParallel

Send tasks to a fleet of remote workers

Custom properties:
  - config|tasks|task.x-*
  - are simply ignored

Content negotiation:
  - autoformat
     - use it in stringify/parse
     - add multipart/form-data format:
        - parsed as { "VAR[;filename=FILE][;content-type=MIME]": VAL, ... }
        - stringify not on plain object should throw
        - each VAL is parsed according to that MIME, or left as unparsed string otherwise
     - should maybe default to raw format instead of throwing exception
  - Content-Type [C]:
     - intersection of:
        - types supported by library (for serialization)
        - merge (override) of:
           - def: application/json
           - spec.consumes
           - test.request.headers.content-type
              - matched case-insensitive
              - if specified, must only use:
                 - type 'string'
                 - enum
                 - default|title|description
     - intersection:
        - if empty array, throw that MIME is unsupported
        - should work with MIMEs being just '+EXT'
        - MIME options:
           - if none specified, leave as is
           - if specified by one side or both sides and equal, pick it
           - if specified by both sides and different, do not pick that MIME
  - Accept [C]:
     - same but with:
        - types supported by library (for parsing)
        - def: any
        - spec.produces
        - test.request.headers.accept
  - Content-Type [S]
     - if not among possible library parsers, throw error
     - used to pick how to parse body
     - def: application/octet-stream
     - validate according to same logic as other standard headers
  - [SMALL_]SCHEMA.type 'file':
     - PARAM:
        - during spec normalization, set Content-Type [C] to multipart/form-data
        - adds parameter filename="PARAM_NAME"
     - RESP:
        - validate Content-Type [S] is multipart/form-data
        - validates every part has "filename"
     - when normalizing OpenAPI schema to JSON schema:
        - convert to another type by guessing from other properties, and defaulting to string
        - should propose a PR to OPENAPI-SCHEMA-TO-JSON-SCHEMA (which throws at the moment)

Produce code coverage report

Add fuzzy testing values???
  - maybe propose as an option to JSON-SCHEMA-FAKER???

Also test middleware (not endpoints)

Add support for $data in x-tests JSON schemas
  - should be able to target merged response body, response headers, request
    parameters

Explore:
  - test runners, reporting
  - fuzzy testing
  - stress testing
  - load testing
  - test coverage

To improve???
  - reduce amount of mocking needed by users
  - reduce amount of setup and teardown (e.g. starting server) needed by users
     - including faking authentication

Plugins:
  - move plugins to own repositories
  - create a repository with some core plugins already included, so users don't have to
  - remove CORE_PLUGINS array

Schemes:
  - support over protocols than HTTP
     - including WebSocket
  - support OPERATION.schemes
  - unless OPTS.endpoint was given, should randomly pick protocol among SPEC|OPERATION.schemes for each test

Think about using OpenAPI 2.0 collectionFormat or OpenAPI 3.0 styles outside of OpenAPI

Add support for HTTP authentication, OAuth2 and OpenID

Add support for OpenAPI 3.0, RAML, API blueprint
  - should use a specification abstraction layer
  - if api-elements is not good enough, create own

Re-use autoserver's ajv error beautification utility (separate it in a different module)

Load test file re-using same logic as autoserver to allow many formats ("autoformat")

Globbing:
  - go through globbing in to_learn.txt to improve current usage of globbing (e.g. in config.tasks or in 'glob' plugin)
  - allow passing directories (included recursively) to config.tests

Reporters:
  - go through CLI doc in to_learn.txt to improve current reporters
  - in 'min' reporter, replace spinner by progress bar
  - add other reporters:
     - see list in my reporters doc: minimal sentence, sentence, dot, progress, nyan, plane, flat, spec, markdown, styleless
       HTML, static HTML, dynamic HTML, JSON stream, XUnit, JUnit, NUnit, Teamcity, AppVeyor
     - try to use a generic input (not test-openapi-specific) so that they can be used by other projects
        - i.e. same idea as TAP but using a stream of JavaScript objects instead of using TAP string parsing
  - use autoformat with 'object' reporter

Dynamic properties keys:
  - problematic on parameter generation and response validation
     - for parameter name, response header names, OpenAPI schema properties
     - OpenAPI only allows static keys
  - possible solution:
     - use 'REGEXP' for keys
     - transform to patternProperties instead of properties
        - both ajv and JSON-SCHEMA-FAKER should then handle it correctly
     - how to mark that a key is a REGEXP not a STR??? Possible solutions:
        - all keys are REGEXPs
        - "/.../" key
        - global OPT
        - testOpt
        - property in specification, e.g. x-*
     - need to work with other specification formats too

Snapshot testing:
  - persist (if not yet) response.raw string as is and check difference on next run
  - persist in a Markdown file with code blocks (i.e. can be used as documentation, and gives nice git diff)
  - automatic pruning (i.e. delete snapshot folder before writing to it)
  - what about dynamic attributes (e.g timestamps)???
  - how to update snapshots???
     - think of CI mode

Add configuration file and logic:
  - re-use same logic as autoserver
  - including JSON references (including in task files)

Improve config.report.notify:
  - go through to_learn.txt
  - show project icon in popup

Check autoserver for feature suggestions:
  - including special linting tool

JSON schema v7:
  - allow v7 in OpenAPI SCHEMA
  - problems:
     - not supported by OpenAPI yet, i.e. OPENAPI-SCHEMA-TO-JSON-SCHEMA outputs JSON schema v4, but this is not a problem
     - however does not work with JSON-SCHEMA-FAKER yet

Cancel other sub-tests once one sub-test failed:
  - including HTTP request using AbortController:
     - not supported by node-fetch yet: https://github.com/bitinn/node-fetch/pull/437
  - including writing request bodies and reading response bodies (abort STREAMs)

Allow [SMALL_]SCHEMA.x-validate:
  - custom validation similar to autoserver's
  - needs to be added to AJV
  - problem with JSON-SCHEMA-FAKER:
     - not supported as is
     - might be even harder when it comes to combining with not|allOf|anyOf|oneOf

autopackage:
  - abtraction of package.json for many programming languages and OS package managers
  - automatically creates other package.json-like files
  - should whitelist the format we want,  to avoid pollution???
  - automatically publish:
     - maybe using a common user controlled by me
  - paying option:
     - to allow publishing
     - GitHub hooks

Business idea:
  - CI features:
     - executes requests on cloud/FaaS
     - notifications (GitHub hooks, etc.)
  - configuration editor
     - linting
     - execute as you type
  - nice reporting
