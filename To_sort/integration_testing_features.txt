Rename test.response to test.validate and test.fetchResponse to test.response
Rename testOpts to initialTest???

Plugin architecture:
  - plugin configuration:
     - CONF.PLUGIN_NAME: overall configuration
     - test.PLUGIN_NAME: request-specific configuration
  - plugin exports a PLUGIN object with callback functions:
      - PLUGIN.beforeAll({ conf, tests, runTests }): at very beginning
      - PLUGIN.beforeEach({ conf, test, runTest }): before each fetch
      - PLUGIN.afterEach({ conf, test }): after each fetch
      - PLUGIN.afterAll({ conf, tests }): at very end
  - callback functions can modify (replacing them) their arguments (CONF, test.*) by returning them
  - callback functions:
      - can be async/awaited
      - but only follow promise if a promise is returned (like the promiseThen() utility from autoserver) to avoid too many microtasks
         - in the same idea, Promise.all(ARR) should become simply ARR if none is a promise
  - separate everything to plugins:
      - configuration loading and validation
      - tests loading
      - repeat and parallel
      - depReqs
      - spec merging
      - request generation
      - request serialization
      - actual fetch
      - response parsing
      - response validation
  - other possible plugins: load testing, saving to files, selecting tests, reporting, etc.
  - whether a plugin is enabled or not by default is plugin-specific
  - PLUGIN.order FLOAT:
      - exported by each plugin
      - in beforeAll|beforeEach, plugins are run in increasing order
      - in afterAll|afterEach, inverse
      - if several plugins have same order, they are run in parallel
  - PLUGIN.name "PLUGIN_NAME"
  - PLUGIN.required "PLUGIN_NAME"_ARR: throw error if other plugin is not installed
  - all plugins installed in node_modules are loaded by default
  - PLUGIN.overrides "PLUGIN_NAME"_ARR: disable other plugins, e.g. to override core plugins
  - validate exported PLUGINs with a JSON schema
  - rename CONF.tests???
      - e.g. to CONF.requests
      - rename also default glob to **/*.requests.EXT???
  - any error thrown from a plugin should be error.type should be "PLUGIN_NAME"
      - wrap each plugin with error handler to make that automatic and ensure it

Test running:
  - should run NUM it() in parallel
     - NUM = OPTS.maxParallel / OPTS.repeat
     - in different microloops (for async parallelism)
     - in different processes (for CPU parallelism) (not as important)
     - maybe switch to ava to get that
     - should stop on failure if OPTS.stopOnFail true (def)
  - pass options to underlying test runner, e.g. reporters, reporting options, include|exclude, etc.
     - all those concerns should be offloaded to the test runner
     - maybe add OPTS.runner to choose between different runners (i.e. they would be adapters)
     - maybe force a specific runner???
     - maybe only allow specific runner options???
     - maybe force output to TAP format to allow different reporters???
  - probably:
     - use library to maintain NUM workers, where NUM is number of CPU cores
     - assign equal number of it() to each
        - they each spawn the same test file, but with a modulo to filter which tests they define
     - force a specific test runner:
        - should allow concurrent tests to have a maxParallel limit
        - should have lots of features, which should be directly accessible (and whitelisted) from user perspective
        - should report in TAP format, and add --reporter=MODULE option that points to tap reporter
  - things I might need the test runner for:
     - reporters
     - test REGEX selection
     - parallelism
     - allow test option to be a directory searched recursively
     - exclude option
     - test.only() and test.skip()
     - bail
  - --dry:
     - when --dry, should not show any reporter output
     - but should print the first thrown error.message

Content negotiation:
  - Content-Type [C]:
     - intersection of:
        - types supported by library (for serialization)
        - merge (override) of:
           - def: application/json
           - spec.consumes
           - test.request.headers.content-type
              - matched case-insensitive
              - if specified, must only use:
                 - type 'string'
                 - enum
                 - default|title|description
     - intersection:
        - if empty array, throw that MIME is unsupported
        - should work with MIMEs being just '+EXT'
        - MIME options:
           - if none specified, leave as is
           - if specified by one side or both sides and equal, pick it
           - if specified by both sides and different, do not pick that MIME
  - Accept [C]:
     - same but with:
        - types supported by library (for parsing)
        - spec.produces
        - test.request.headers.accept
  - Content-Type [S]
     - if not among possible library parsers, throw error
     - used to pick how to parse body
     - def: application/octet-stream
     - validate according to same logic as other standard headers
  - add response body parsing for:
     - x-www-url-encoded (using QUERYSTRING) as an OBJ
        - use body-parser library instead???
     - multipart/form-data (using another library) as an OBJ
  - add request param serializating for:
     - x-www-form-urlencoded and multipart/form-data:
        - PARAM must be an OBJ:
           - for body: [SMALL_]SCHEMA.type must be 'object'
           - for formData: it is always an OBJ
        - do not set multipart/form-data parameter Content-Type
  - add support for formData PARAM:
     - validate Content-Type [C] can only be x-www-form-urlencoded or multipart/form-data
     - uses { PARAM_NAME: generatedValue, ... }
     - there can be several PARAMs of that type
  - [SMALL_]SCHEMA.type 'file':
     - PARAM:
        - validate Content-Type [C] is multipart/form-data
        - adds parameter filename="PARAM_NAME"
     - RESP:
        - validate Content-Type [S] is multipart/form-data
        - validates every part has "filename"
     - when normalizing OpenAPI schema to JSON schema:
        - convert to another type by guessing from other properties, and defaulting to string
        - should propose a PR to OPENAPI-SCHEMA-TO-JSON-SCHEMA (which throws at the moment)

Produce code coverage report

Add fuzzy testing values???
  - maybe propose as an option to JSON-SCHEMA-FAKER???

Also test middleware (not endpoints)

Add support for $data in x-tests JSON schemas
  - should be able to target merged response body, response headers, request
    parameters

Explore:
  - test runners, reporting
  - fuzzy testing
  - stress testing
  - load testing
  - test coverage

To improve???
  - reduce amount of mocking needed by users
  - reduce amount of setup and teardown (e.g. starting server) needed by users
     - including faking authentication

Divide repository into smaller modules: request building, response validation, etc.

Schemes:
  - support over protocols than HTTP
     - including WebSocket
  - support OPERATION.schemes
  - unless OPTS.endpoint was given, should randomly pick protocol among SPEC|OPERATION.schemes for each test

Add support for HTTP authentication, OAuth2 and OpenID

Add support for OpenAPI 3.0, RAML, API blueprint
  - should use a specification abstraction layer
  - if api-elements is not good enough, create own

Re-use autoserver's ajv error beautification utility (separate it in a different module)

Load test file re-using same logic as autoserver to allow many formats ("autoformat")
  - should validate against circular references, but by adding this as a feature to autoformat

Dynamic properties keys:
  - problematic on parameter generation and response validation
     - for parameter name, response header names, OpenAPI schema properties
     - OpenAPI only allows static keys
  - possible solution:
     - use 'REGEXP' for keys
     - transform to patternProperties instead of properties
        - both ajv and JSON-SCHEMA-FAKER should then handle it correctly
     - how to mark that a key is a REGEXP not a STR??? Possible solutions:
        - all keys are REGEXPs
        - "/.../" key
        - global OPT
        - testOpt
        - property in specification, e.g. x-*
     - need to work with other specification formats too

Add configuration file and logic:
  - re-use same logic as autoserver

Check autoserver for feature suggestions:
  - including special linting tool

JSON schema v7:
  - allow v7 in OpenAPI SCHEMA
  - problems:
     - not supported by OpenAPI yet, i.e. OPENAPI-SCHEMA-TO-JSON-SCHEMA outputs JSON schema v4, but this is not a problem
     - however does not work with JSON-SCHEMA-FAKER yet

Cancel other sub-tests once one sub-test failed:
  - including HTTP request using AbortController:
     - not supported by node-fetch yet: https://github.com/bitinn/node-fetch/pull/437
  - including writing request bodies and reading response bodies (abort STREAMs)

Allow [SMALL_]SCHEMA.x-validate:
  - custom validation similar to autoserver's
  - needs to be added to AJV
  - problem with JSON-SCHEMA-FAKER:
     - not supported as is
     - might be even harder when it comes to combining with not|allOf|anyOf|oneOf

autopackage:
  - abtraction of package.json for many programming languages and OS package managers
  - automatically creates other package.json-like files
  - should whitelist the format we want,  to avoid pollution???
  - automatically publish:
     - maybe using a common user controlled by me
  - paying option:
     - to allow publishing
     - GitHub hooks

Business idea:
  - CI features:
     - executes requests on cloud/FaaS
     - notifications (GitHub hooks, etc.)
  - configuration editor
     - linting
     - execute as you type
  - nice reporting
