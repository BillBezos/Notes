
       
   JOI  
       



ALTERNATIVES ==>                  #See JSON-schema

VERSION ==>                       #13.1.2
                                  #Node and browser (requires "joi-browser" package)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASSERTIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.assert(VAL, SCHEMA[, 'ERROR'])#Validate SCHEMA by throwing error
                                  #'ERROR' is prepended to error message

JOI.validate(VAL, SCHEMA          #Validate SCHEMA by passing ERROR|null to FUNC()
[, OPTS][, FUNC(ERROR|null,VAL2)])#If no FUNC:
->PROMISE(VAL2, ERROR|null)       #  - returns PROMISE for async
                                  #  - PROMISE.error ERROR and PROMISE.value VAL2 are also set for sync
                                  #VAL2 is deep copy of VAL.
                                  #OPTS:
                                  #  - abortEarly BOOL:
                                  #     - if true (def), stops on first error
                                  #     - VAL2 deep copy might be incomplete
                                  #  - convert BOOL:
                                  #     - if true (def), VAL2 is cast to SCHEMA type instead of throwing.
                                  #     - still does deep copy
                                  #     - can also perform some similar transformations, e.g. STR_SCHEMA.lower|uppercase|trim()
                                  #  - stripUnknown BOOL: if true (def: false) and VAL is OBJ, if keys are among the available
                                  #    ones in the schema, erase them in VAL2
                                  #  - allowUnknown BOOL: if true (def: false) and VAL is OBJ, if keys are among the available
                                  #    ones in the schema, throw error
                                  #  - skipFunctions BOOL: same but only for keys being FUNC
                                  #  - context CONTEXT_OBJ: see below
SCHEMA.validate(VAL[, FUNC])      #Same as JOI.validate(VAL, SCHEMA, FUNC)

ERROR                             #ValidationError
ERROR.isJoi                       #true
ERROR.details                     #OBJ_ARR:
                                  #  - message STR
                                  #  - path 'VAR'_ARR
                                  #  - type 'VALIDATION_FUNC'
                                  #  - context OBJ: validation rule-specific detailed information
ERROR.annotate([BOOL])->STR       #Prints a diff between actual and expected value
                                  #If BOOL false (def), colored

JOI                               #Base SCHEMA
SCHEMA                            #All methods returns a new immutable SCHEMA, so chainable


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          REFERENCES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REF                               #VARR being a relative path among siblings
                                  #If starts with "$" (or JOI.ref()'s OPTS.contextPrefix), look into CONTEXT_OBJ
                                  #instead of current object.
JOI.ref('REF'[, OPTS])->SCHEMA    #SCHEMA to use as a value and representing a sibling (like a JSON reference)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LOGIC             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SCHEMA_ARR
JOI.alternatives(SCHEMA[_ARR]...)
JOI.alternatives().try
 (SCHEMA[_ARR]...)                #Can be used as SCHEMA, meaning "any of SCHEMA_ARR".

SCHEMA.concat(SCHEMA2)->SCHEMA3   #Means "all of those schemas" (i.e. must be same type)

SCHEMA.when(SCHEMA3, OBJ2)        #Adds OBJ2.then|otherwise SCHEMA2 according to condition SCHEMA3
SCHEMA.when('REF', OBJ2)          #Same but using OBJ2.is SCHEMA3, and applying it to JOI.ref('REF')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERIC            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.any()                         #For any type
                                  #Since JOI is already a SCHEMA, simply using JOI is shorter syntax
SCHEMA.[in]valid(VAL[_ARR]...)    #Whitelist|blacklist values.
                                  #Whitelisting has priority over blacklisting
VAL[_ARR]                         #Can use VAL[_ARR] directly as SCHEMA instead:
                                  #  - e.g. JOI.validate(VAL, VAL2) is same as JOI.validate(VAL, JOI.valid(VAL2))
SCHEMA.allow(VAL[_ARR]...)        #Same as valid(), but if whitelisted, all others don't become blacklisted
SCHEMA.required|forbidden()       #Key must [not] be defined

SCHEMA.options(OPTS)              #Override default OPTS in SCHEMA.validate()
SCHEMA.strict()                   #Override OPTS.convert as false

SCHEMA.default(VAL)               #If undefined, replace by VAL in SCHEMA.validate() VAL2

SCHEMA.description(STR)
SCHEMA.notes(STR_ARR)
SCHEMA.tag(STR[_ARR])
SCHEMA.meta(OBJ)
SCHEMA.example(VAL)
SCHEMA.unit(STR)                  #Meta information (doesn't do anything)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BOOLEAN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.boolean()                     #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            NUMBER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.number()                      #
NUM_SCHEMA.integer()              #
NUM_SCHEMA.min|max(NUM)           #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.string()                      #By default invalid(''): must allow('') to use ''
STR_SCHEMA.insensitive()          #Make allow|[in]valid() case-insensitive (must be after)
STR_SCHEMA.min|max|length
(NUM[, STR2])                     #STR length validation (using encoding STR2)
STR_SCHEMA.regex(REGEXP)          #
STR_SCHEMA.alphanum()             #
STR_SCHEMA.token()                #[[:alnum:]_]
STR_SCHEMA.email()                #
STR_SCHEMA.guid()                 #
STR_SCHEMA.isoDate()              #
STR_SCHEMA.hostname()             #
STR_SCHEMA.lower|uppercase()      #Using OPTS.convert
STR_SCHEMA.trim()                 #Using OPTS.convert


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ARRAY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.array()                       #
ARR_SCHEMA.in|excludes(SCHEMA...) #Each value must sequentially [not] validate against any of them
ARR_SCHEMA.min|max|length(NUM)    #Array length validation


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OBJECT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.object()                      #
{}
OBJ_SCHEMA.keys({})               #Validates OBJ is empty
{ KEY: SCHEMA2 }
OBJ_SCHEMA.keys
 ({ KEY: SCHEMA2 ... })           #Validate children
OBJ_SCHEMA.pattern(REGEXP,SCHEMA2)#Validate children whose key matches REGEXP, unless they match something in OBJ_SCHEMA.keys()

OBJ_SCHEMA.assert                 #Validates REF value
('REF', VAL[, 'ERROR'])           #REF cannot be top-level property

OBJ_SCHEMA.unknown([BOOL])        #If true (def), allow keys not present in OBJ_SCHEMA.keys() during validation

OBJ_SCHEMA.min|max|length(NUM)    #Validates number of keys
OBJSCHEMA.and|or|xor(KEY, KEY2)   #Validates KEY and KEY2 presences together.
OBJ_SCHEMA.with[out](KEY, KEY2)   #Validates that if KEY, then [not] KEY2
OBJ_SCHEMA.rename                 #Transform keys (using OPTS.convert).
(KEY, KEY2[, OPTS])               #Done before validation.
                                  #OPTS (all def false):
                                  #  - override BOOL: KEY2 can already exist for the first rename()
                                  #  - multiple BOOL: KEY2 can exist for the other rename()
                                  #  - alias BOOL: keep KEY


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DATE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.date()                        #
DATE_SCHEMA.min|max(DATE)         #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.func()                        #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BUFFER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.binary()                      #Validates BUFFER
BIN_SCHEMA.min|max|length(NUM)    #BUFFER size validation
BIN_SCHEMA.encoding(STR)          #
