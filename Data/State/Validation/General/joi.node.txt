
       
   JOI  
       



VERSION ==>                       #4.6.1

JOI.assert(VAL, SCHEMA)           #Validate SCHEMA by throwing error

JOI.validate(VAL, SCHEMA          #Validate SCHEMA by passing ERROR|null to FUNC()
[, OPTS][, FUNC(ERROR|null,VAL2)])#If no FUNC, returns sync. { error: ERROR, value: VAL2 }
                                  #VAL2 is deep copy of VAL.
                                  #OPTS:
                                  #  - abortEarly BOOL:
                                  #     - if true (def), stops on first error
                                  #     - VAL2 deep copy might be incomplete
                                  #  - convert BOOL:
                                  #     - if true (def), VAL2 is cast to SCHEMA type instead of throwing.
                                  #     - can also perform some similar transformations, e.g. STR_SCHEMA.lower|uppercase|trim()
                                  #  - stripUnknown BOOL: if true (def: false) and VAL is OBJ, if keys are among the available
                                  #    ones in the schema, erase them in VAL2
                                  #  - allowUnknown BOOL: if true (def: false) and VAL is OBJ, if keys are among the available
                                  #    ones in the schema, throw error
                                  #  - skipFunctions BOOL: same but only for keys being FUNC
                                  #  - context CONTEXT_OBJ: see below
SCHEMA.validate(VAL[, FUNC])      #Same as JOI.validate(VAL, SCHEMA, FUNC)

SCHEMA                            #All methods returns SCHEMA, so chainable


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         COMPLEX TYPES         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REF                               #VARR being a relative path among siblings
                                  #If starts with "$" (or OPTS.contextPrefix for JOI.ref()), look into CONTEXT_OBJ
                                  #instead of current object.
JOI.ref('REF'[, OPTS])->SCHEMA    #SCHEMA to use as a value and representing a sibling (like a JSON reference)

SCHEMA_ARR
JOI.alternatives()                #Can be used as SCHEMA, meaning "any of SCHEMA_ARR".

SCHEMA[_ARR].when('REF', OBJ2)    #Adds a SCHEMA2 conditionally according to a REF
                                  #OBJ2:
                                  #  - is SCHEMA3: the condition, matched against REF
                                  #  - then|otherwise SCHEMA2

SCHEMA.concat(SCHEMA2)->SCHEMA3   #Means "all of those schemas" (i.e. must be same type)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            SCHEMAS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JOI.any()->SCHEMA                 #For any type
SCHEMA.[in]valid(VAL[_ARR]...)    #Whitelist|blacklist values:
                                  #  - last defined between whitelist|blacklist has priority
                                  #  - if one whitelisted, all others become blacklisted
                                  #  - can add several whitelist|blacklist values
                                  #  - can use VAL[_ARR] directly as SCHEMA instead???
SCHEMA.allow(VAL[_ARR]...)        #Same as valid(), but if whitelisted, all others don't become blacklisted
SCHEMA.required|forbidden()       #Key must [not] be defined

SCHEMA.options(OPTS)              #Override default OPTS in SCHEMA.validate()
SCHEMA.strict()                   #Override OPTS.convert as false

SCHEMA.default(VAL)               #If undefined, replace by VAL in SCHEMA.validate() VAL2

SCHEMA.description(STR)
SCHEMA.notes(STR_ARR)
SCHEMA.tag(STR[_ARR])
SCHEMA.meta(OBJ)
SCHEMA.example(VAL)
SCHEMA.unit(STR)                  #Meta information (doesn't do anything)

JOI.boolean()->SCHEMA             #

JOI.number()->SCHEMA              #
NUM_SCHEMA.integer()              #
NUM_SCHEMA.min|max(NUM)           #

JOI.string()->SCHEMA              #By default invalid(''): must allow('') to use ''
STR_SCHEMA.insensitive()          #Make allow|[in]valid() case-insensitive (must be after)
STR_SCHEMA.min|max|length
(NUM[, STR2])                     #STR length validation (using encoding STR2)
STR_SCHEMA.regex(REGEXP)          #
STR_SCHEMA.alphanum()             #
STR_SCHEMA.token()                #[[:alnum:]_]
STR_SCHEMA.email()                #
STR_SCHEMA.guid()                 #
STR_SCHEMA.isoDate()              #
STR_SCHEMA.hostname()             #
STR_SCHEMA.lower|uppercase()      #Using OPTS.convert
STR_SCHEMA.trim()                 #Using OPTS.convert

JOI.array()->SCHEMA               #
ARR_SCHEMA.in|excludes(SCHEMA...) #Each value must sequentially [not] validate against any of them
ARR_SCHEMA.min|max|length(NUM)    #Array length validation

JOI.object()->SCHEMA              #
OBJ_SCHEMA.keys({})               #Validates OBJ is empty
OBJ_SCHEMA.keys
 ({ KEY: SCHEMA2 ... })           #Validate children
OBJ_SCHEMA.pattern(REGEXP,SCHEMA2)#Validate children whose key matches REGEXP, unless they match something in OBJ_SCHEMA.keys()

OBJ_SCHEMA.assert
('REF', VAL[, 'ERROR'])           #Validates REF value

OBJ_SCHEMA.unknown([BOOL])        #If true (def), allow keys not present in OBJ_SCHEMA.keys() during validation

OBJ_SCHEMA.min|max|length(NUM)    #Validates number of keys
OBJSCHEMA.and|or|xor(KEY, KEY2)   #Validates KEY and KEY2 presences together.
OBJ_SCHEMA.with[out](KEY, KEY2)   #Validates that if KEY, then [not] KEY2
OBJ_SCHEMA.rename                 #Transform keys (using OPTS.convert).
(KEY, KEY2[, OPTS])               #Done before validation.
                                  #OPTS (all def false):
                                  #  - override BOOL: KEY2 can already exist for the first rename()
                                  #  - multiple BOOL: KEY2 can exist for the other rename()
                                  #  - alias BOOL: keep KEY

JOI.date()->SCHEMA                #
DATE_SCHEMA.min|max(DATE)         #

JOI.func()->SCHEMA                #

JOI.binary()->SCHEMA              #Validates BUFFER
BIN_SCHEMA.min|max|length(NUM)    #BUFFER size validation
BIN_SCHEMA.encoding(STR)          #
