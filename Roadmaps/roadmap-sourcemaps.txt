
                      
   ROADMAP-SOURCEMAPS  
                      



Should target Node 6.0

GitHub/npm organization "sourcemaps" and @sourcemaps scope (@sourcemaps/has)

Separate the content|location utility checker
  - including opts.base

@sourcemaps/regex

@sourcemaps/base(content|location[, { base }])[->'URI|PATH']
  - returns:
     - if location, dirname(location)
     - if //# sourceURL, use its dirname()
     - otherwise opts.base
  - if relative, relative to opts.base
  - opts.base:
     - def: process.cwd() or dirname(window.location.href)
     - can be either:
        - relative: normalized to absolute, being relative to process.cwd()
        - absolute URI
        - absolute path
  - returns either absolute URI or absolute path

@sourcemaps/has(content|location[, { base }])->BOOL
  - if no sourceMappingURL, tries to see if sibling `.map` file exists
     - prefetch it right away

@sourcemaps/get(content|location[, { base }])->{ location, inline, multiline }
  - location is absolute|relative URI, absolute|relative path or data URI
  - no format nor mime check
  - no base64 nor JSON parsing
  - inline is boolean
  - if no sourceMappingURL, tries to see if sibling `.map` file exists
     - prefetch it right away

@sourcemaps/remove(content)->content

@sourcemaps/set(content, sourcemapLocation[, { multiline }])->content
  - remove() then append

@sourcemaps/validate(sourcemapContent|sourcemapLocation)[->ERROR]
  - check source map syntax

@sourcemaps/fetch(sourcemapLocation|headers[, { base }])->{ sourcemap, validate }
  - if (after applying opts.base if relative):
     - data URI:
        - check format and MIME
        - base64 decoding
     - relative path or absolute file:///...: local file read
     - HTTP[S]: GET request
        - can also be headers with [X]-SourceMap [S]
     - otherwise error
  - JSON parsing
  - validate() if true (def: false)

@sourcemaps/read(content|location[, { base }])->{ location, inline, multiline, sourcemap, validate }
  - get()
  - fetch()

@sourcemaps/write(path, sourcemap[, { base, inline, multiline, validate }]):
  - set()
  - validate() if true (def: false)
  - persist file
  - persist source map (unless inline)
  - inline|multiline default to same as current one

@sourcemaps/delete(path[, { base }]):
  - remove() but persist file and remove source map file too

@sourcemaps/transform(path, function[, { base, inline, multiline, validate, all }])
  - read() then function then write()
  - function is FUNC(sourcemap)[->sourcemap]
     - can return `undefined` to remove sourcemap
     - if opts.all true (def: false), called with `undefined` when no sourcemap (i.e. creates one)

@sourcemaps/copy(path, origPath)
  - goal: copy|move directory/file without breaking source maps
  - transform() using function:
     - if there is a source map, modify its sourceRoot:
        - if sourceRoot absolute: do nothing
        - if sourceRoot relative: set as path.posix.relative(sourceRoot, dirname(ORIG_FILE))
           - note: source map format only allows forward slashes
        - if sourceRoot absent:
           - if all "sources" are absolute: do nothing
           - set as path.posix.relative(dirname(DEST_FILE), dirname(ORIG_FILE))
     - if there is no source map, generate:
        - version: 3
        - sourceRoot: ORIG_DIR (i.e. common ancestors of all ORIG_FILE)
        - file: path.posix.relative(ORIG_DIR, ORIG_FILE)
        - sources: [basename(ORIG_FILE)]
        - sourcesContent: [JSON.stringify(readFile(ORIG_FILE, { encoding: 'utf-8' }))]
        - names: nothing
        - mappings: use source-list-map modules (i.e. line-by-line mapping)
           - (new SourceListNode(sourcesContent, file, sourcesContent)).getMappings(new MappingsContext)
           - can do token-by-token mapping when creating a new source map like IDENTITY-MAP does,
             i.e. by parsing with language-specific parser
              - fallback to line-by-line mapping

Documentation check:
  - check old source map versions differences
  - fix source map documentation about uri vs path

support //# sourceURL

Index maps???

Other tools like concat???

Dir recursion on any above???

Streaming???

Vinyl support???
