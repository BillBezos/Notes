*Done today*

_ICO lists_
  - big performance improvements:
     - previously retrieving popular lists would fetch all ICO lists then sort/paginate them on the API (instead of the database)
       This was not scalable and likely to be very slow (> 10 seconds or more) as more ICO lists are being created.
       This was already slow (about 1.5 seconds) even with about 300 ICO lists currently in production.
       This problem is now fixed.
     - all `List` endpoints are now much faster by persisting `List.ratings` on list create/update
        - fix `populatedev` script accordingly
     - make most `List` endpoints faster by running some database requests in parallel where it was previously done serially
     - `DELETE /lists/:listId` is now faster
  - remove duplicate attributes: both `List.ratings.likesCounts|dislikesCount|rankingScore` and `List.likesCount|dislikesCount|rankingScore` were present
  - allow `GET /lists?order=ratings` as a shortcut for `GET /lists?order=-ratings.rankingScore -ratings.dislikesCounts _id`
  - make `List.userData.rating` required (i.e. return `neutral` instead of `null`)
  - bug fixes:
     - any user can delete any lists
     - allow anyone to rate lists, not just their owner
  - `List.userData.rating` should default to `neutral` not `null`
  - remove dead code (sorting utility)

_Dependencies_
  - Upgrade ESLint

To do:
  - List:
     - perform database migration on stage/production:
        db.lists.find({}).forEach(({ _id: listId }) => { const likesCount = db.user_list_rating.count({ list: listId, rating: "like" }); const dislikesCount = db.user_list_rating.count({ list: listId, rating: "dislike" }); const rankingScore = (function(pos, n) { if (n === 0) { return 0 } let z = 1.96; let phat = (1 * pos) / n; return ( (phat + (z * z) / (2 * n) - z * Math.sqrt((phat * (1 - phat) + (z * z) / (4 * n)) / n)) / (1 + (z * z) / n)) })(likesCount, likesCount + dislikesCount); db.lists.updateOne({ _id: listId }, { $set: { ratings: { likesCount, dislikesCount, rankingScore } } }) })
     - List.items:
        - replace by `List.icos` ID_ARR
        - either validate or remove duplicate List.items
     - front-end bug:
        - ICO that have already been added to a list still show up in "Add ICO" dropdown on /my-lists
        - when sorting ICOs in /my-lists, it jitters
     - once API documentation for `Lists` is in production, ask for feedback on API documentation since now `List` and
       `Metrics` are fully documented
  - integrationTestWatch should remove require() cache on watch???
     - otherwise changing source code does not reload it
  - X-Response-Time
  - fix deleted ICOs still showing up: https://trello.com/c/rQuTpeyV/86-deleted-icos-are-still-available-in-the-ico-details-page-url
  - blog post about test-openapi
  - integration testing
     - also test middleware (not only endpoints)
  - refactoring:
     - make status codes more consistent and hide behind a common interface
     - refactor authentication to simplify it
  - migrations:
     - check production database matches our data model (perform live queries to fix it otherwise)
     - automated system that syncs staging database with production database
     - system to perform and test migrations against production database
  - add a model layer between controller and Mongoose:
     - provide caching invalidation functionality
     - provide ICO slug update functionality
     - make any DELETE flag the model as deleted, but not removed from database
  - upgrade node.bcrypt.js to fix security vulnerability (when they release a version)
  - Gulp buildwatch crashes (does not watch anymore) after the first OpenAPI error
  - switch Jasmine to Jest, like in front-end
  - Node 10
  - 404 are HTML even in JSON
  - add Flow
  - RSS/Atom
  - generate client SDKs from OpenAPI: JavaScript, Bash, others
  - update API documentation to Widdershins
 Â - replace current dependency REQUEST by CROSS-FETCH
  - lint-staged currently does not allow committing only half of a file
  - use declarative way (with JSON-SCHEMA-MOCKER) instead of current approach for populating scripts
  - create fake|test database from OpenAPI:
     - can maybe specify in OpenAPI if a specific type of data is prefered
        - e.g. at least one user should be admin
        - can use faker, etc.
     - can replace populating scripts
     - can be merged with the test populating task at beginning of integration tests
  - use JSON schema instead of joi:
     - probably using SWAY.validateRequest|Response()
     - first use JSON schema during integration testing, then suggesting merging
        - maybe use enjoi as transition
     - possible advantages of JSON schemas:
        - declarative:
           - can be communicated to clients so they can validate before sending to APIs
              - there are even library to generate <form> and <input>
           - schema is data not code, i.e. easier to manipulate for other purpose
              - e.g. can be used for auto-documentation
        - we do not want to be loose on validation with sanitization, but fail hard instead
           - joi is built as sanitizer, e.g. every validation creates a deep copy
        - not JavaScript-specific
        - https://github.com/icebob/validator-benchmark
     - also validate response
     - also parse request parameters
  - replace server-driven populating by client-driven populating:
     - first refactor populating so that each route declaratively specify which models to populate instead of
       doing it imperatively
     - then let clients decide it with a query parameter instead of declaring it on the routes
     - same for:
       - filter
       - aggregation
       - pagination
       - sorting
       - population
  - generate Mongoose models from OpenAPI specification
  - add GraphQL:
     - swagger-to-graphql would allow automating it while still supporting REST
     - I estimated it at 2 days of work
  - other possible uses of OpenAPI:
     - server-side routing
     - web automation
     - mock server
  - yamllint

To do (front-end app):
  - keep .editorconfig in sync with back-end one

Ideas:
  - gamification:
     - simple overall/aggregate ranking number
     - widget/badges showing "certified by"
     - rankings, "best of the week"
     - think of potentialpark

Tools to update:
  - MongoDB, mongoose
  - nvm
  - cors
  - helmet
  - moment
  - morgan
  - winston, winston-mongodb, winston-sentry
  - lodash

Tools to learn (high priority):
  - Flow (they mentioned adding it):
     - maybe also TypeScript
     - go through to_learn to check related projects too
  - Heroku
  - Circle CI
  - ElasticSearch
  - documentation, static website generation (for API doc generation)
  - web security:
     - snyk

Tools to learn (priority):
  - yarn
  - Sentry
  - HTTPS
  - Mailgun
  - Twilio
  - Stripe

Tools to learn:
  - dotenv, nconf
  - express-rate-limit
  - express-useragent
  - geoip-lite
  - libphonenumber-js
  - husky, lint-staged
