
         
   MOIZE  
         



VERSION ==>                       #5.4.0

MOIZE(FUNC[, OPTS])->FUNC
MOIZE(OPTS)(FUNC)->FUNC

MOIZE(MOIZE2)->MOIZE              #Composition, e.g. MOIZE.maxSize(NUM)(MOIZE.deep)
MOIZE.compose(...MOIZE2)->MOIZE   #

MOIZE.deep(FUNC)->FUNC            #Same as MOIZE(FUNC, { isDeepEqual: true })
MOIZE.maxAge(NUM)(FUNC)->FUNC     #Same as MOIZE(FUNC, { maxAge: NUM })
MOIZE.maxArgs(NUM)(FUNC)->FUNC    #Same as MOIZE(FUNC, { maxArgs: NUM })
MOIZE.maxSize(NUM)(FUNC)->FUNC    #Same as MOIZE(FUNC, { maxSize: NUM })
MOIZE.promise(FUNC)->FUNC         #Same as MOIZE(FUNC, { isPromise: true, updateExpire: true })
MOIZE.simple(FUNC)->FUNC          #Same as MOIZE(FUNC, { maxSize: 1 })
MOIZE.react(FUNC)->FUNC           #Same as MOIZE(FUNC, { isReact: true })
MOIZE.reactSimple(FUNC)->FUNC     #Same as MOIZE(FUNC, { isReact: true, maxSize: 1 })
MOIZE.serialize(FUNC)->FUNC       #Same as MOIZE(FUNC, { serialize: true })

ARGS                              #Values passed as arguments to memoized FUNC, as an ARR
KEYS                              #Cache keys (for all arguments), as an ARR
KEY                               #Cache key (of a single argument)

OPTS.matchesKey(KEYS, KEYS2)->BOOL#How KEYS are compared
OPTS.equal(ARG, KEY)->BOOL        #How ARG and KEY are compared
                                  #Def: Object.is() or (if OPTS.isDeepEqual true (def: false)) util.isDeepStrictEqual()
OPTS.isPromise                    #If true (def: false), do not cache if return value is a rejected PROMISE
OPTS.isReact                      #If true (def: false), do a shallow comparison on ARG.props|context
                                  #(i.e. it is a React stateless component)

OPTS.serializer(ARGS)->STR_ARR    #How KEY are computed (def: ???)
OPTS.isSerialized                 #If false (def), disable OPTS.serializer()
OPTS.transformArgs(ARGS)->ARGS    #Map ARGS before OPTS.serializer()
OPTS.maxArgs                      #Only keep first NUM ARGS for OPTS.serializer()
OPTS.shouldSerializeFunction      #If true (def: false), serialize functions

OPTS.maxAge                       #Expiration time NUM (in ms)
OPTS.updateExpire                 #Reset expiration time on cache hit
OPTS.onExpire(CACHE, OPTS, FUNC)  #Fired on expiration
 ->BOOL                           #If false is returned, do not expire and reset expiration time

OPTS.maxSize                      #LRU caching size NUM

OPTS.onCacheAdd(CACHE, OPTS, FUNC)#Fired on new cached KEY
OPTS.onCacheChange
 (CACHE, OPTS, FUNC)              #Fired on new cached KEY, or on cache hit leading to LRU cache reordering
OPTS.onCacheHit(CACHE, OPTS, FUNC)#Fired no cache hit

FUNC.isMoized()->BOOL             #

MOIZE|FUNC.collectStats()         #Start recording stats
MOIZE|FUNC.getStats               #OBJ:
 (["PROFILE"])->OBJ               #  - calls NUM
                                  #  - hits NUM
                                  #  - usage "NUM%"
                                  #  - profiles.PROFILE.calls|hits|usage
                                  #"PROFILE":
                                  #  - OPTS.profileName (def: FUNC.name + line|column|source info)
                                  #  - used to differentiate between groups of functions
MOIZE|FUNC.isCollectingStats()
 ->BOOL                           #

MOIZE.cache                       #CACHE
MOIZE.cacheSnapshot               #Shallow clone of MOIZE.cache (because that one is directly mutated)

CACHE.keys                        #KEYS_ARR
CACHE.values                      #ARR (return values, same order as CACHE.keys)
CACHE.size                        #NUM

FUNC.keys()->KEYS_ARR             #
FUNC.values()->ARR                #

FUNC.get(KEYS)->VAL               #Undefined if not existing
FUNC.has(KEYS)->BOOL              #
FUNC.add(KEYS, VAL)               #Add cached values, if not existing yet
FUNC.update(KEYS, VAL)            #Update cached values if existing
FUNC.remove(KEYS)                 #Noop if not existing
FUNC.clear()                      #Clear all cache
