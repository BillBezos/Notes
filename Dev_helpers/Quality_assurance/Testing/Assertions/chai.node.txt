
        
   CHAI  
        



VERSION ==>                       #4.1.2
                                  #Node.js or browser

MOCHA ==>                         #Usually used by Mocha, but does not have to


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             BASE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


VAL.should                        #SHOULD
                                  #CHAI.should() must first be fired to extend OBJ prototype with OBJ.should
                                  #VAL cannot be null|undefined
CHAI.expect(VAL)                  #SHOULD
new CHAI.Assertion(VAL)           #SHOULD
CHAI.assert(VAL)                  #SHOULD (other API not as good)

SHOULD                            #Object wrapping VAL, which is accessed with SHOULD._obj
SHOULD CHAIN ==>                  #All members returns SHOULD, so can be chained, e.g. VAL.should.exist.and.be.ok
                                  #There are two types of members along the chains:
                                  #  - methods: assertion on SHOULD._obj, internally using SHOULD.assert()
                                  #  - properties: add an internal "flag" along the chain, that will influence next methods

SHOULD.assert(BOOL, STR[()],      #Throws AssertionError('MESSAGE') if BOOL false. Noop if BOOL true.
 STR2[()][, VAL][, VAL2])         #Used internally by all assertion methods.
                                  #STR[2]:
                                  #  - positive|negative error message
                                  #  - usually "expected ... to VERB ..."
                                  #  - can include following template patterns:
                                  #     - "#{this}": SHOULD._obj
                                  #     - "#{exp}": VAL (expected value)
                                  #     - "#{act}": VAL2 (def: SHOULD._obj) (actual value)
                                  #"Internal error message":
                                  #  - STR3 prepended to error message (def: "")
                                  #  - specified as optional last argument to all assertion method, or to new CHAI.Assertion(VAL, STR)
                                  #  - usually specific to the calling code, not to the generic assertion problem

CHAIUTILS.flag                    #Gets|sets a "flag"
 (SHOULD, 'VAR'[, 'VAL'])         #Some flags used by most assertions:
                                  #  - "object": underlying VAL. Can also use SHOULD._obj
                                  #  - "message": "internal error message"
                                  #  - "negate" BOOL: flag .not
                                  #  - "deep" BOOL: flag .deep
                                  #  - "contains" BOOL: flag .include.*
                                  #  - "length" BOOL: flag .length.*
                                  #When creating a new flag, should either create properties|methods handling it,
                                  #or overwrite current ones.
CHAIUTILS.transferFlags           #Copy this's flags to SHOULD, except "object" and "message" (unless BOOL is true)
 (this, SHOULD[, BOOL])           #To use on final assertions inside a custom property|method, that create a SHOULD,
                                  #to make sure flags are propagated.
                                  #Not to use:
                                  #  - when checking preconditions
                                  #  - on final assertions with SHOULD.assert() (not affected by flags)

CONFIG VAR ==>                    #Can be used by Mocha reporters
CHAI.config.showDiff              #Show diff (def: true)
CHAI.config.truncateThreshold     #Truncates VAL length (def: 40, 0 to disable)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EXTENSIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CHAI.use(FUNC(CHAI, CHAIUTILS))   #Fires FUNC().
                                  #FUNC are usually plugins MODULE which fire CHAI.Assertion.*

CHAI.Assertion.addProperty        #Makes SHOULD.PROP firing FUNC2() with SHOULD as this.
('PROP', FUNC2())                 #Usually meant to:
                                  #  - assert preconditions with this.*
                                  #  - use CHAIUTILS.flag()
CHAI.Assertion.addMethod          #Same for SHOULD.FUNC(...).
('FUNC', FUNC2(...))              #Usually FUNC2() includes actual assertions (as opposed to preconditions) with this.assert()

CHAI.Assertion.addChainableMethod #Same as CHAI.Assertion.addMethod(STR, FUNC); CHAI.Assertion.addProperty(STR, FUNC2), except:
(STR, FUNC, FUNC2)                #  - it cannot be overwritten (case of a, an, include, length)
                                  #  - method FUNC() also fire property FUNC2()

CHAI.Assertion.overwriteMethod    #Overwrite SHOULD.FUNC(...)
('FUNC', FUNC3(SUPER)->FUNC2(...))#If SHOULD.FUNC() is overwritten only for specific preconditions (e.g. if input is HTML),
                                  #can call original method with SUPER.call(this, ...)
CHAI.Assertion.overwriteProperty
('PROP', FUNC2(SUPER)->FUNC3())   #Same for SHOULD.PROP


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERIC            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SHOULD.be                         #
SHOULD.have[.been]                #
SHOULD...that|which
 [.is|has[.been]|does]            #
SHOULD...and|but                  #
SHOULD.with|at|of|same|to         #Same as SHOULD (doesn't do anything), provided only for BDD-style syntax

SHOULD.not                        #Negation

SHOULD.satisfy(FUNC(VAL)->BOOL)   #

SHOULD.equal(VAL)                 #===. Compare OBJ by reference.
SHOULD.deep.equal(VAL)            #===. Compare OBJ by copy (including inherited) (using Object.is())
SHOULD.eql(VAL)                   #Like deep.equal() except "deep" flag is not set

SHOULD.[be.]null|undefined        #=== null|undefined
SHOULD.exist                      #!== null|undefined
CHAI.should().[not.]exist(VAL)    #When using VAL.should

SHOULD.[be.]true|false            #=== true|false
SHOULD.[be.]ok                    #== true|false
SHOULD.[be.]NaN                   #Object.is(NaN)
SHOULD_ARR|OBJ.[be.]empty         #=== ""|[]|{}

SHOULD.[be.]above|[at.]least|
 below|[at.]most(NUM)             #> >= < <=
SHOULD.[be.]within(NUM, NUM2)     #> and <
SHOULD.[be.]closeTo(NUM, NUM2)    #>= NUM-NUM2 and <= NUM+NUM2

SHOULD.[be.a[n]](STR)             #typeof STR ('number|string|null|undefined|symbol') or
                                  #'Object|Array|RegExp|Date|function|Arguments|[Weak]Map|Set|Promise|*Array|ArrayBuffer|DataView' or
                                  #toString()->STR
SHOULD.[be.an.]instanceof(FUNC)   #VAL instanceof TYPE
SHOULD.[be.]arguments             #Is arguments object


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SHOULD_STR.match(REGEXP)          #
SHOULD_STR.
 include[s]|contain[s](STR2)      #
SHOULD_STR.[have.]string(STR2)    #STR2 is inside STR

SHOULD_STR[be.of.]length(NUM)     #STR.length === NUM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         ARRAY|OBJECT          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SHOULD_ARR|SET|MAP.
 [deep.]include[s]|contain[s](VAL)#One value [deep.]equal(VAL)
SHOULD_ARR.[deep.]
 include[s]|contain[s].members
 (ARR2)                           #ARR2 is a subset of ARR (use [deep.]equal)

SHOULD_OBJ.[deep.][own|nested.]   #OBJ2 [deep] subset of OBJ
 include[s]|contain[s](OBJ2)      #If "own", non-inherited only.
                                  #If "nested", OBJ2 keys can be a dot|bracket-delimited VARR

SHOULD_OBJ|ARR.[have.][deep.]     #Check property exists.
[own|nested.]property             #"own|nested": like include()
('PROP'[,VAL])[.that[.is]|with...]#If VAL, also checks property [deep.]equal(VAL)
                                  #The assertion value from OBJ to OBJ.PROP for the rest of the chain, e.g.:
                                  #  SHOULD_OBJ.have.property(...).that.is.true.with.property(...).that.is.false
SHOULD_OBJ|ARR.[have.]
 ownPropertyDescriptor
 ('PROP'[, VAL])][...]            #Same except VAL (and the new assertion value) is the object descriptor
SHLD_OBJ|ARR.have|contain.any.keys
 ('PROP'[_ARR]...)                #At least one property should exist
SHOULD_OBJ|ARR.contain.all.keys
 ('PROP'[_ARR]...)                #All properties should exist
SHOULD_OBJ|ARR.have.all.keys
 ('PROP'[_ARR]...)                #All properties should exist, and no other properties should exist

SHOULD_OBJ|ARR.[be.of.]length(NUM)#OBJ|ARR.length === NUM
SHOULD_OBJ.[itself.]respondTo     #Check property exists and it is a function.
 ('FUNC')                         #Not through prototype if "itself"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SHOULD_FUNC().throw
 ([ERROR|REGEXP|STR])             #

SHOULD_FUNC().change(OBJ, 'PROP') #OBJ.PROP should be different before|after FUNC() called
SHOULD_FUNC().increase|decrease
 (OBJ, 'PROP')                    #OBJ.PROP should increase|decrease before|after FUNC() called


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DATE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SHOULD_DATE.equal|before|         ##With "Date": same but truncates after day.
afterTime|Date(DATE2)             ##Module chai-datetime 1.4.0
SHOULD_DATE.withinTime|Date
 (DATE2, DATE3)                   ##


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTML              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CHAI-JQUERY ==>                   ##Only in browser. Should be included.
                                  ##Version 2.0.0

SHOULD_JQ.[have.]attr|prop|
css|data(VAR[, VAL])              ##Checks with JQ.attr|prop|css|data()
SHOULD_JQ.[have.]class(CLASS)     ##
SHOULD_JQ.[have.]id(ID)           ##
SHOULD_JQ.[have.]value(VAL)       ##Check with JQ.val()
SHOULD_JQ.match(CSS_SELECTOR)     ##Check with JQ.is()
SHOULD_JQ.descendants
(CSS_SELECTOR)                    ##Check with JQ.has()
SHOULD_JQ.[have.]
html|text(STR)                    ##Check match entirely with JQ.html|text()
SHOULD_JQ.contain(STR)            ##Check match partially with CSS selector :contains(STR)
SHOULD_JQ.[be.]visible|hidden|
selected|checked|enabled|
disabled|empty                    ##Check with CSS selector ":visible", etc.
SHOULD_JQ.exist                   ##Not of length 0


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROMISE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CHAI-AS-PROMISED ==>              ##All return a CHAIPROMISE (module chai-as-promised 5.0.0), a PROMISE with only then() member.
                                  ##To extend it, use CHAI-AS-PROMISED.transferPromiseness = FUNC(SHOULD, PROMISE), where
                                  ##FUNC() assign SHOULD.NEWFUNC = PROMISE.FUNC.bind(PROMISE) (this is PROMISE not CHAIPROMISE)
                                  ##For wd.js, can do it with:
                                  ##  CHAI-AS-PROMISED.transferPromiseness = WD.transferPromiseness;
                                  ##So BROWSER.should.eventually returns a BROWSER, not a CHAIPROMISE
                                  ##Can also use CHAI-AS-PROMISED.transformAsserterArgs = FUNC(ARR)->ARR, which will modify
                                  ##resolved VAL before VAL.should.FUNC2(...) is called.
SHOULD_PROMISE.[be.]fulfilled     ##PROMISE should be resolved
SHOULD_PROMISE.eventually.
FUNC2(...)                        ##PROMISE should be resolved and resolve with VAL and VAL.should.FUNC2(...).
SHOULD_PROMISE.become(VAL)        ##Same as SHOULD_PROMISE.eventually.deep.equal(VAL)
SHOULD_PROMISE.[be.]rejected
SHOULD_PROMISE.[be.]
rejectedWith(VAL)                 ##PROMISE should be rejected [with VAL]

