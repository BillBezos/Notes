
                           
   JASMINE_JEST_ASSERTIONS  
                           



ALTERNATIVES ==>                                #See chai

VERSION ==>                                     #Part of Jasmine|Jest (see their docs)
                                                #Generic assertions

JASMINE VS JEST ==>                             #Jest uses Jasmine under the hood.
                                               A#This means Jasmine-only
                                               a#This means Jasmine-only but due to Jest using older version 2.5.2-light of Jasmine
                                               E#This means Jest-only
JASMINE                                         #Jest uses expect.* instead of JASMINE.* but only JASMINE is noted in this
                                                #documentation unless it is Jest-only


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERIC            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


expect(VAL)                                     #EXPECT

EXPECT.not...                                   #Invert assertion

EXPECT.nothing()                               a#Noop

EXPECT.toBe(VAL2)                              A#=== VAL2
                                               E#Object.is()
EXPECT.toEqual(VAL2)                            #== VAL2
                                                #For OBJ, compare own enumerated by copy

EXPECT.toBeInstanceOf(TYPE)                    E#instanceof TYPE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        NULL|UNDEFINED         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPECT.toBeDefined|Undefined()                  #=== undefined
EXPECT.toBeNull()                               #=== null


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BOOLEAN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPECT_BOOL.toBeTruthy|Falsy()                  #== true|false


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            NUMBER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPECT_NUM.toBeNaN()                            #Object.is(NaN)
EXPECT_NUM.toBePositive|NegativeInfinity()     a#=== Infinity|-Infinity

EXPECT_NUM.toBeLess|GreaterThan[OrEqual](NUM)   #< > <= >= NUM
EXPECT_NUM.toBeCloseTo(NUM[, NUM2])             #== Math.round(NUM, NUM2)
                                                #Def NUM2: 2


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPECT_STR.toMatch(REGEXP)                      #REGEXP.test(STR)
EXPECT_STR.toContain(STR2)                      #Is substring
EXPECT_STR.toHaveLength(NUM)                   E#STR.length === 0


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         ARRAY|OBJECT          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPECT_ARR.toContain(VAL)                      E#Any ARR element.toBe(VAL)
EXPECT_ARR.toContainEqual(VAL)                 E#Any ARR element.toEqual(VAL)
EXPECT_ARR.toContain(VAL)                      A#Any ARR element.toEqual(VAL)
EXPECT_ARR.toHaveLength(NUM)                   E#ARR.length === 0

EXPECT_OBJ.toHaveProperty                      E#OBJ.VARR !== undefined
 ('VARR'|'VAR'_ARR[, VAL])                     E#If VAL, OBJ.VARR.toEqual(VAL)
EXPECT_OBJ|ARR.toMatchObject(OBJ2|ARR2)        E#OBJ2|ARR2 is a subset of OBJ|ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPECT_FUNC.toThrow()                           #
EXPECT_FUNC.toThrow(VAL)                       A#Using toEqual()
EXPECT_FUNC.toThrowError([TYPE], [STR|REGEXP])  #Def TYPE is Error
EXPECT_FUNC.toThrowMatching
 (FUNC(ERROR)->BOOL)                           a#

                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROMISE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPECT_PROMISE.resolves|rejects.*(...)         E#PROMISE should be resolved|rejected
                                               E#The resolved|rejected value should EXPECT(VAL).*(...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        DEEP ASSERTION         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DEEP ASSERTIONS ==>                             #Assertions that can either be used:
                                                #  - top-level, e.g. EXPECT.toEqual(JASMINE.any(TYPE))
                                                #  - nested level, e.g. EXPECT.toEqual({ ..., VAR: JASMINE.any(TYPE) })

EXPECT.toEqual                                  #FUNC(VAL)->BOOL
 ({ asymmetricMatch: FUNC, ... })               #`this` is { ... } (must not use arrow functions)
                                                #Can also do the reverse (i.e. assymetricMatch(...) on the expected value) but not both.

EXPECT.toEqual(JASMINE.anything())              #!== undefined|null
EXPECT.toEqual(JASMINE.any(TYPE))               #instanceof TYPE

EXPECT_BOOL.toEqual(JASMINE.falsy|truthy())    a#== false|true

EXPECT_STR.toEqual
 (JASMINE.stringMatching(REGEXP|'REGEXP'))      #REGEXP.test(STR)
EXPECT_STR.toEqual(JASMINE.[not]empty())       a#=== ''
EXPECT_STR.toEqual
 (expect.stringContaining(STR))                E#Is substring

EXPECT_ARR.toEqual(JASMIN.arrayContaining(ARR2))#ARR2 is a subset of ARR (using toEqual())
                                                #Duplicates are removed. Order does not matter.
EXPECT_ARR.toEqual                             a#ARR2 has exact same elements as ARR (using toEqual())
 (JASMINE.arrayWithExactContents(ARR2))        a#Order does not matter.

EXPECT_OBJ.toEqual(JASMN.objectContaining(OBJ2))#OBJ2 is a subset of OBJ (using toEqual())
EXPECT_OBJ|ARR.toEqual(JASMINE.[not]empty())    #=== {}|[]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PLAN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


expect.assertions(NUM)                         E#Exactly NUM EXPECT.*() (except EXCEPT.[has]assertions()) are called in current test
expect.hasAssertions()                         E#Same for more than 0 EXPECT.*()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTML              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPECT_ELEM.toHaveClass('CLASS')               a#Check HTML class


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EXTENSIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JASMINE.addCustomEqualityTester                A#Will be used in toEqual(), providing it does not return undefined.
 (FUNC(VAL, VAL2)->BOOL|undefined)             A#Must be done in beforeAll()


MATCHER                                         #FUNC(UTIL, TESTERS)->OBJ:
                                                #  - compare(VAL[, ARG...])->OBJ2:
                                                #     - pass BOOL
                                                #     - message STR:
                                                #        - "Expected VAL [not] to be ..."
                                                #        - def. ...: use CUSTOM by adding space between camelcase
                                                #        - must be set even if pass true, but using "not"
                                                #  - negativeCompare(...):
                                                #     - same but used when "not" is used
                                                #     - def: just inverse pass BOOL
JASMINE.addMatchers({ CUSTOM: MATCHER ... })    #Add custom assertion EXPECT.CUSTOM([ARG...]):
                                                #Must be in beforeAll()

UTIL.equals(VAL, VAL2, TESTERS)->BOOL           #Like toEqual() (including using deep assertions)
UTIL.contains(ARR|STR, VAL|STR2, TESTERS)->BOOL #Like toContain()
