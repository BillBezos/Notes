
            
   ISTANBUL  
            


TODO: follow projects on Feedly???



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              RUN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/



NYC ==>                           #11.8.0
ISTANBUL-API ==>                  #1.3.2

NYC VS ISTANBUL-API ==>           #NYC is CLI, ISTANBUL-API is programmatic usage.
                                  #They both use same core libraries, however NYC does not use ISTANBUL-API directly

nyc [OPTS] ...                    #Call NYC.wrap(), then run ... then NYC.report()
                                  #Can use same options as nyc instrument|report, plus some extra

--cwd                             #Used for several purposes, including NCONF loading, resolution of
                                  #NCONF.reportDir|tempDirectory|cacheDirectory, NCONF.exclude|include, NCONF.require
                                  #Def: ENV_VAR NYC_CWD, package root, or process.cwd()

--include|n 'GLOB'                #Whitelists files to instrument
                                  #Def: everything in --cwd
                                  #Can use '!GLOB'
                                  #Uses micromatch
                                  #Can be done several times
                                  #Based on monopackage "test-exclude"
--exclude|x 'GLOB'                #Same but for blacklisting
                                  #Def: 'coverage|__tests__|test/**' and '[*-]test[-*].js'
                                  #Always excluded: 'node_modules/**'
                                  #Can be done several times
--exclude-after-remap             #If true (def), apply --exclude after applying source maps as well
--extension|e '.EXT'              #Def: ['.js']
                                  #Can be done several times


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CACHING/TEMP          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


nyc [MANY_COMMANDS] ...           #
--temp-directory DIR              #Def: './.nyc-output'

--cache|c                         #Caches instrumentation to cache directory (./node_modules/.cache/nyc/)
                                  #Def: true
--babel-cache                     #Def: false
                                  #Sets ENVVAR BABEL_DISABLE_CACHE '1'

nyc ...                           #Creates temp directory and cache directory
--clean                           #First removes temp directory


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONFIG             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NCONF vs CONF                     #NCONF is NYC's, CONF is ISTANBUL-API's


NCONF                             #Can be:
                                  #  - package.json "nyc" NCONF
                                  #  - --nycrc-path JSON_NCONF_FILE
                                  #  - [.../]./.nycrc[.json] JSON_NCONF_FILE
NYC_CONFIG NCONF                  #ENVVAR set by nyc ...

new Nyc(NCONF)                     #


CONF_OBJ                          #Plain object
CONF                              #CLASS
CONF.PROP()->VAL                  #Gets CONF_OBJ.PROP (camelCase instead of dasherized)

ISTANBUL-API.config.
 defaultConfig()->CONF_OBJ        #
ISTANBUL-API.config.loadObject
 ([CONF_OBJ], [CONF_OBJ2])->CONF  #CONF_OBJ has less priority than default one, CONF_OBJ2 has more
ISTANBUL-API.config.loadFile
 (['CONF_FILE'],[CONF_OBJ2])->CONF#Same with a YAML|JSON FILE (def: './.istanbul.yml')

CONF.verbose                      #Debugging console.log()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        INSTRUMENTATION        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


nyc [OPTS] ...                    #Does not run nyc instrument but run hooks
--all|a                           #If true (def: false), first run NYC.addAllFiles()
--eager                           #Def: false

nyc instrument [OPTS] 'FILE|DIR'
 ['FILE2|DIR2']                   #Call NYC.instrumentAllFiles('FILE|DIR'[, 'FILE2|DIR2'])
--require|i STR                   #Def: none
                                  #Can be done several times
--compact                         #Def: true
--preserve-comments               #Def: true
--instrument                      #Def: true
                                  #If false, instrumentation is noop

NYC.instrumentAllFiles('FILE|DIR',#Instrument all files in 'FILE|DIR':
 [, 'FILE2|DIR2']FUNC([ERROR]))   #  - using ISTANBUL-LIB-INSTRUMENT.createInstrumenter(OPTS).instrumentSync()
                                  #  - with OPTS:
                                  #     - autoWrap true
                                  #     - coverageVariable '__coverage__'
                                  #     - esModules true
                                  #     - compact|preserveComments|ignoreClassMethods: from NCONF.*
                                  #  - delayed until first INSTRUMENTER.instrumenterSync() if NCONF.eager true
                                  #Outputs to 'FILE2|DIR2' (def: stdout)
                                  #Also: first require() all NCONF.require

NYC.addAllFiles()                 #Like instrumentAllFiles() but:
                                  #  - retrieve and persist COVMAP right away
                                  #  - i.e. COVMAP counters will be empty
                                  #  - but all files will be present in COVMAP, even ones that are never run


ISTANBUL-API.instrument.run       #Instrument OPTS.input 'PATH':
 (CONF, OPTS, FUNC())             #  - using ISTANBUL-LIB-INSTRUMENT.createInstrumenter(OBJ).instrumentSync()
                                  #  - with CONF.instrumentation OBJ (dasherized)
                                  #     - coverageVariable is called variable (def: '__coverage__')
                                  #Then writes the result to OPTS.output 'PATH' (def: stdout)
                                  #Can use OPTS.input|output 'DIR':
                                  #  - OPTS.includes:
                                  #     - def ['**/*'] if CONF.completeCopy true (def: false)
                                  #     - otherwise [**/*.EXT] using CONF.extensions '.EXT'_ARR (def: ['.js'])
                                  #  - OPTS.excludes
                                  #     - uses CONF.excludes (def: [])
                                  #     - adds ['**/node_modules/**'] if CONF.defaultExcludes true (def)
                                  #If OPTS.saveBaseline true (def: false):
                                  #  - creates a COVEMAP with each INSTRUMENTER.lastFileCoverage() (i.e. empty counters)
                                  #  - saves it to to OPTS.baselineFile (def: './coverage/coverage-baseline.raw.json')


ISTANBUL-LIB-INSTRUMENT ==>       #1.10.1
                                  #Instrument JavaScript code so it stores coverage information when run.

ISTANBUL-LIB-INSTRUMENT.
 createInstrumenter([OPTS])       #OPTS:
 ->INSTRUMENTER                   #  - variable STR (def: '__coverage__')
INSTRUMENTER.instrumentSync       #In a nutshell:
 ('CODE'[, 'FILENAME'])->'CODE'   #  - set a global FILECOV (for this FILENAME) with source code's line|column|name information
                                  #  - add FILECOV.s|f|b.CID++ before each statement|function|branch
                                  #Instrument code:
                                  #  - prepends code that create a new FILECOV:
                                  #     - referenced by both global.__coverage__.FILENAME and a local variable
                                  #        - i.e. global.__coverage__ is a COVMAP
                                  #     - all FILECOV.statement|fn|branchMap.CID set to their related source code's line|column|name
                                  #     - all FILECOV.s|f|b.CID initialized to 0
                                  #  - adds counters:
                                  #     - FILECOV.s.CID++ before each statement
                                  #     - FILECOV.f.CID++ before each function
                                  #     - FILECOV.b.CID[INDEX]++ before each child branch
                                  #Do it by:
                                  #  - parsing JavaScript 'CODE' to AST (with Babylon, see its doc)
                                  #     - using options:
                                  #        - sourceType 'script' if OPTS.esModules false (def) or 'module'
                                  #        - plugins ['asyncGenerators', 'dynamicImport', 'objectRestSpread', 'flow', 'jsx']
                                  #        - allowReturnOutsideFunction OPTS.autoWrap BOOL (def: false)
                                  #  - traversing and transforming AST (with babel-traverse, see its doc)
                                  #     - can access only that logic using ISTANBUL-LIB-INSTRUMENT.ProgramVisitor
                                  #  - generating JavaScript 'CODE' from AST (with babel-generator, see its doc)
                                  #     - using options:
                                  #        - compact OPTS.compact BOOL (def: true): minify whitespaces
                                  #        - comments OPTS.preserveComments BOOL (def: false)
                                  #Noop if applied twice
                                  #Def 'FILENAME': 'TIMESTAMP.js'
INSTRUMENTER.instrument('CODE'
 [, 'FILENAME'], FUNC('CODE'))    #Same (is actually sync as well) but with different signature

INSTRUMENTER.lastFileCoverage()
 ->FILECOV                        #

// istanbul ignore file [COMENT]  #Skip instrumentation for current file
// istanbul ignore next [COMENT]  #Skip instrumentation for next block|structure
// istanbul ignore if|else [CMT]  #Skip instrumentation for next if|else
OPTS.ignoreClassMethods           #Skip instrumentation for 'FUNC'_ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HOOK              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


nyc ...                           #First runs NYC.wrap()
--hook-run-in-[this]-context      #Def: true

NYC.wrap()                        #ISTANBUL-LIB-HOOK.hook*(() => true, instrumentation (like instrumentAllFiles()), OPTS) with OPTS:
                                  #  - extensions NCONF.extensions
                                  #  - hookRequire(): always, hookRunIn[This]Context: according to NCONF.hook-run-in-this-context
                                  #On process exit, write COVMAP to temporary directory
                                  #Call all require() from NCONF.require


ISTANBUL-API.instrument.cover     #Target source files:
 (CONF[, 'GLOB'_ARR],             #  - including:
 FUNC(ERROR, COVER_OBJ))          #     - 'GLOB'_ARR
                                  #     - def: '**/*.EXT' using CONF.extensions '.EXT'_ARR (def: ['.js'])
                                  #  - excluding:
                                  #     - uses CONF.excludes (def: [])
                                  #     - adds ['**/node_modules|test|tests/**'] if CONF.defaultExcludes true (def)
                                  #     - adds CONF.reporting.dir 'DIR' (def: './coverage')
                                  #  - at CONF.instrumentation.root (def: '.')
                                  #  - unless CONF.includeAllSources true (def: false), do not report files that are never require()'d
COVER_OBJ.hookFn()                #Run ISTANBUL-LIB-HOOK.hookRequire(..., OPTS2)
                                  #  - with OPTS2:
                                  #     - extensions OPTS.extensions
                                  #     - verbose OPTS.verbose
                                  #     - coverageVariable '$$coverage$$'
                                  #  - that runs ISTANBUL-LIB-INSTRUMENT.createInstrumenter(OPTS2).instrumentSync() with OPTS2:
                                  #     - CONF.instrumentation OBJ (dasherized)
                                  #     - coverageVariable '$$coverage$$'
                                  #  - uses ISTANBUL-LIB-HOOK.hookRunIn[This]Context() instead if
                                  #    CONF.hooks.hookRunIn[This]Context true (def: false)
COVER_OBJ.unhookFn()              #Unhook and also run ISTANBUL-LIB-HOOK.unloadRequireCache()


ISTANBUL-LIB-HOOK ==>             #1.2.0

ISTANBUL-LIB-HOOK.
 hookRequire(FUNC('PATH')->BOOL,  #Monkey patches require():
 FUNC2(STR, { filename })->STR,   #  - applies FUNC2 first
 [OPTS])->FUNC3()                 #  - only if FUNC BOOL is true
                                  #  - do it by using deprecated require.extensions
                                  #FUNC3() disables it (but does not remove monkey patching)
                                  #OPTS:
                                  #  - extensions STR_ARR (def: ['.js'])
                                  #  - postLoadHook('FILENAME'): fired after each require()
                                  #  - verbose BOOL (def: false): debugging console.log()
ISTANBUL-LIB-HOOK.
 unloadRequireCache(FUNC)         #Removes require.cache of files matching FUNC('PATH')->BOOL

ISTANBUL-LIB-HOOK.                #Same but using VM.createScript|runIn[This]Context() instead of hookRequire()
 hookCreateScript|                #With runInContext():
 runIn[This]Context(...)          #  - sets GLOBAL.__coverage__ to reference of same empty OBJ in both current context and child context
                                  #  - can customnize '__coverage__' name using OPTS.coverageVariable
ISTANBUL-LIB-HOOK.
 unhookCreateScript|
 runIn[This]Context()             #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     BABEL-PLUGIN-ISTANBUL     :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


VERSION ==>                       #4.1.6
                                  #Babel plugin that instrument code with ISTANBUL-LIB-INSTRUMENT
                                  #There is a related Babel configuration available also at monopackage "nyc-config-babel" (1.2.3)

PLUGIN_OPTS.include|exclude
 'GLOB'[_ARR]                     #Same as NCONF.include|exclude

PLUGIN_OPTS.useInlineSourceMaps   #BOOL (def: true)

PLUGIN_OPTS.onCover
 (FUNC('PATH', FILECOV))          #Optional event handler



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          SOURCE MAPS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


nyc instrument ...                #
--source-map                      #Def: true
--produce-source-map              #Def: false

NYC.instrumentAllFiles()          #Passes NCONF.produceSourceMap to ISTANBUL-LIB-INSTRUMENT.createInstrumenter(OPTS)
                                  #Before INSTRUMENTER.instrumentSync():
                                  #  - get initial source maps:
                                  #     - get SOURCE_MAP using CONVERT-SOURCE-MAP.fromSource|fromMapFileSource()
                                  #     - MAPSTORE.registerMap('FILENAME', SOURCE_MAP)
                                  #After INSTRUMENTER.instrumentSync():
                                  #  - write new source maps (if NCONF.produceSourceMap true)
                                  #     - INSTRUMENTER.lastSourceMap()
                                  #     - merged to initial source maps if any
                                  #     - added as inline base64 sourceMappingURL (using CONVERT-SOURCE-MAP.toComment())

nyc --all
nyc merge|check-coverage|report   #Use MAPSTORE.transformCoverage(COVMAP)

INSTRUMENTER.lastSourceMap()      #Uses babel-generator options:
 ->SOURCE_MAP_OBJ                 #  - sourceMaps OPTS.produceSourceMap BOOL (def: false)
                                  #  - sourceFileName 'FILENAME'
                                  #To multi-map into an already existing SOURCE_MAP, add it as last argument to instrumentSync()
                                  #OPTS.sourceMapUrlCallback('FILENAME', 'sourceMappingURL') is called by instrumentSync() if defined
                                  #  - e.g. ISTANBUL-LIB-SOURCE-MAPS.registerURL

COVER_OBJ.exitFn(OPTS2)           #Apply MAPSTORE.transformCoverage(COVMAP):
                                  #  - uses returned sourceFinder as reporters' sourceFinder
                                  #  - instrumenter uses OPTS2.sourceMapUrlCallback MAPSTORE.registerURL()

CONTEXT.getSource('PATH')->STR    #Runs either:
                                  #  - FS.readFileSync()
                                  #  - OPTS.sourceFinder('PATH')->STR if defined
                                  #     - e.g. the one from ISTANBUL-LIB-SOURCE-MAPS to get source file's content,
                                  #       not compiled file

ISTANBUL-LIB-SOURCE-MAPS ==>      #1.2.4
                                  #Modifies line|column numbers in coverage results by applying a source map

ISTANBUL-LIB-SOURCE-MAPS.
 createSourceMapStore([OPTS])
 ->MAPSTORE                       #
MAPSTORE.transformCoverage(COVMAP)#Returns a new COVMAP2 with each FILECOV.inputSourceMap applied to each line|column number
 ->{ map COVMAP2, sourceFinder }  #Uses mozilla source-map's CONSUMER.originalPositionFor() (see its doc)

FILECOV.inputSourceMap            #SOURCE_MAP
MAPSTORE.registerMap
 ('PATH',SOURCE_MAP_OBJ)          #Alternative way instead of specifying FILECOV.inputSourceMap
MAPSTORE.registerURL('PATH', STR) #STR is sourceMappingURL value (base64 or external file)

MAPSTORE.sourceFinder             #If available, uses sourceContent:
 ('SOURCE_PATH')                  #  - cached during MAPSTORE.transformConverage() into OPTS.sourceStore:
 ->'FILE_CONTENT'                 #     - 'memory' (def)
                                  #     - 'file' at OPTS.tmpdir (def: OS.tmpdir())
                                  #Otherwise, reads the file:
                                  #  - relative to OPTS.baseDir 'DIR' (def: process.cwd())

MAPSTORE.dispose()                #Cleanup


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             CHECK             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


nyc ...
--check-coverage                  #Run nyc check-coverage ... before reporting

nyc check-coverage                #Same as ISTANBUL-API.checkCoverage() but CLI and:
                                  #  - if under thresholds, prints it and exit code 1
                                  #  - uses COVMAPs from --temp-directory
                                  #  - def --lines is 90 (0 for others)
--statements|lines|functions|
 branches                         #
--per-file                        #


ISTANBUL-API.checkCoverage        #Check coverage of combined COVMAPs against CONF.check.global.*
 (CONF[,OPTS],FUNC(ERROR|'ERROR'))#If under thresholds, ERROR|'ERROR'
                                  #Uses COVMAPs from:
                                  #  - OPTS.includes (def: '**/coverage*.json')
                                  #  - at OPTS.root (def: CONF.instrumentation.root (def: '.'))
CONF.check.global.statements|
 lines|functions|branches         #0-100. Def: 0
CONF.check.each.*                 #Like CONF.check.global.* but for each file's FILECOV instead of combined COVMAPs
CONF.check.excludes               #'PATH'_ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           REPORTING           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


nyc ...                           #Runs nyc report ... at end
--silent|s                        #Do not run nyc-report

nyc report [OPTS]                 #Same as ISTANBUL-API.reports.run() except gets all COVMAPs from --temp-directory
--reporter|r 'FORMAT'             #Def: 'text'
--report-dir 'DIR'                #Def: 'coverage'
--skip-empty                      #FORMAT's OPTS.skipEmpty (def: false)
--show-process-tree               #Show all Node.js spawn during reporting


ISTANBUL-API.reports.run          #Gets all COVMAPs from OPTS:
 ('FORMAT'_ARR,CONF[,OPTS],FUNC())#  - root 'DIR' (def: process.cwd())
                                  #  - includes (def: '**/coverage*.raw.json')
                                  #  - excludes ['**/node_modules/**']
                                  #For each COVMAP, report it with ISTANBUL-API.createReporter()
ISTANBUL-API.createReporter
 (CONF[, OPTS])->REPORTER         #
REPORTER.addAll('FORMAT'_ARR)
REPORTER.add('FORMAT')            #Specify 'FORMAT'
REPORTER.write(COVMAP, OPTS)      #Report a COVMAP with each 'FORMAT'
                                  #OPTS is CONF.reporting.report-config

CONF.reporting.dir                #Output dir (def: './coverage')
CONF|OPTS.summarizer              #Whether files are organized:
                                  #  - 'flat': no nesting
                                  #  - 'nested': nested according to directory structure
                                  #  - 'pkg' (def):
                                  #     - same except directories are not nested inside each other
                                  #     - instead they are all siblings, i.e. depth level is 2
CONF.reporting.watermarks.
 statements|lines|functions|
 branches                         #[NUM, NUM2] for green|orange|red color (def: [50, 80])
CONF.reporting.report-config      #FORMAT's OPTS
                                  #All FORMATs have OPTS:
                                  #  - file 'FILENAME'
                                  #     - '-'|null for process.stdout
                                  #     - def is different for each FORMAT


FORMAT 'none'                     #Nothing|silent

FORMAT 'json'                     #Like { 'PATH': FILECONV, ... } as JSON string
                                  #Def 'FILENAME': 'coverage-final.json'
FORMAT 'json-summary'             #{ 'PATH': SUMMARY, ..., total: SUMMARY } as JSON string
                                  #Def 'FILENAME': 'coverage-summary.json'

FORMAT 'text'                     #ASCII table with:
                                  #  - 'FILE' as lines
                                  #  - columns: SUMMARY.lines|statements|functions|branches.pct NUM, FILECOV.getUncoveredFiles()
                                  #Def 'FILENAME': null
                                  #OPTS:
                                  #  - maxCols NUM (def: 0)
                                  #  - skipEmpty BOOL (def: false): skip empty files
FORMAT 'text-summary'             #SUMMARY.lines|statements|functions|branches.pct NUM for all files
                                  #Def 'FILENAME': null

FORMAT 'html'                     #Similar to 'text' but as HTML
                                  #OPTS:
                                  #  - subdir 'DIR': output sub-'DIR'
                                  #  - skipEmpty BOOL (def: false): skip empty files
                                  #  - linkMapper OBJ: customize URLs by mapping them
                                  #  - verbose BOOL (def: false): debugging console.log()

FORMAT 'lcovonly'                 #LCOV (see its doc)
                                  #Def 'FILENAME': 'lconv.info'
FORMAT 'lcov'                     #lcovonly + html
FORMAT 'text-lcov'                #Like lcovonly file OPTS.file '-'

FORMAT 'teamcity'                 #Teamcity's format
                                  #Def 'FILENAME': null
                                  #OPTS: blockName STR (def: 'Code Coverage Summary')
FORMAT 'clover'                   #Atlassian clover's format
                                  #Def 'FILENAME': 'clover.xml'
                                  #OPTS: projectRoot 'DIR' (def: process.cwd())
FORMAT 'cobertura'                #Cobertura's format
                                  #Def 'FILENAME': 'cobertura-coverage.xml'
                                  #OPTS: projectRoot 'DIR' (def: process.cwd())


ISTANBUL-REPORTS ==>              #1.4.0
                                  #Reporters (based on ISTANBUL-LIB-REPORT)
                                  #Not documented here because too low level
ISTANBUL-LIB-REPORT ==>           #1.1.4
                                  #Base helpers for reporters:
                                  #  - FILEWRITER: writing to file|console, raw or XML
                                  #  - summarizers|TREE: organizing and visiting FILECOVs as a tree
                                  #  - few utilities (e.g. watermarks)
                                  #Not documented here because too low level


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DATA              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


nyc merge                         #Get all COVMAPs from DIR and merge them to FILE
--input-directory DIR             #Def: './.nyc-output'
--output-file FILE                #Def: 'coverage.json'

COVER_OBJ.coverageFinderFn()      #Gets global.$$coverage$$ COVMAP
COVER_OBJ.exitFn(OPTS2)           #Gets global.$$coverage$$ COVMAP
                                  #Writes it at 'DIR/coverage[-PID].raw-json'
                                  #  - DIR is CONF.reporting.dir
                                  #  - PID if CONF.instrumentation.includePid true (def: false)
                                  #Reports each COVMAP with ISTANBUL-API.createReporter() using 'FORMAT'_ARR:
                                  #  - CONF.reporting.reports 'FORMAT'_ARR (def: 'lcov')
                                  #  - 'text' and|or 'text-summary' according to CONF.reporting.print 'detail|summary|none|both' (def: 'summary')

ISTANBUL-LIB-INSTRUMENT.          #Returns (from already instrumented code):
 readInitialCoverage('CODE')->OBJ #  - coverageData FILECOV (with counters initialized to 0)
                                  #  - path 'FILENAME'
                                  #  - gcv '__coverage__'


ISTANBUL-LIB-COVERAGE ==>         #Underlying data model for file coverage information
                                  #1.2.0

SUMMARY                           #Summarized single|multiple file[s] coverage information.
                                  #OBJ:
                                  #  - lines:
                                  #     - total NUM: lines executed or not
                                  #     - covered NUM: lines executed
                                  #     - skipped NUM: when using /* istanbul ignore */
                                  #     - pct NUM|'Unknown':
                                  #        - covered / total
                                  #        - 0-100 with 2 decimal digits precision
                                  #        - 100 if total 0
                                  #  - statements|functions|branches: same for statements|functions|branches
ISTANBUL-LIB-COVERAGE.
 createCoverageSummary
 ([SUMMARY])->SUMMARY             #
SUMMARY.toJSON()->OBJ             #
SUMMARY.isEmpty()->BOOL           #SUMMARY.lines.total === 0
SUMMARY.merge(SUMMARY2)           #
 ->SUMMARY                        #Adds SUMMARY2's NUMs to SUMMARY

FILECOV                           #Detailed single file coverage information
                                  #OBJ:
                                  #  - path 'PATH'
                                  #  (number of times statement|function|branch was executed ("hits"))
                                  #  - s.CID NUM
                                  #  - f.CID NUM
                                  #  - b.CID NUM_ARR (each child branch)
                                  #  (line|column information and metadata)
                                  #  - statementMap.CID:
                                  #     - start|end.line|column NUM
                                  #  - fnMap.CID:
                                  #     - loc.start|end.line|column NUM: of the FUNC body
                                  #     - decl.start|end.line|column NUM: of the 'FUNC' name
                                  #     - name 'FUNC'
                                  #  - branchMap.CID:
                                  #     - loc.start|end.line|column NUM (the parent branch)
                                  #     - locations OBJ_ARR: start|end.line|column NUM (each child branch)
                                  #     - type 'if|switch|cond-expr|binary-expr|default-arg': type of node
                                  #       (IfStatement|SwitchStatement|ConditionalExpression|LogicalExpression|AssignmentPattern)
                                  #CID:
                                  #  - same statement|function|branch uses same CID between the counter and the *Map
                                  #  - incrementing 'NUM' for statement|function|branch
ISTANBUL-LIB-COVERAGE.
 createFileCoverage
 (FILECOV|'PATH')->FILECOV        #
FILECOV.toJSON()->OBJ             #
FILECOV.merge(FILECOV2)->FILECOV  #Adds FILECOV2's NUMs to FILECOV
FILECOV.resetHits()               #Resets FILECOV.s|f|b to 0
FILECOV.toSummary()->SUMMARY      #Leaves SUMMARY.*.skipped to 0
                                  #Uses FILECOV.s|f|b
FILECOV.computeSimpleTotals
 ('getLineCoverage'|'s'|'f')
 ->SUMMARY.lines|statements|
 functions                        #
FILECOV.computeBranchTotals()
 ->SUMMARY.branches               #
FILECOV.getLineCoverage()         #Statements coverage (using FILECOV.s|statementMap)
 ->{ LINE_NUM: NUM }              #NUM is the number of times that line's statement was executed
                                  #If several statements, takes the max
FILECOV.getUncoveredLines()
 ->LINE_NUM_ARR                   #Same but only returns lines where no statement was executed
FILECV.getBranchCoverageByLine()  #Branch-wise statements coverage (using FILECOV.b|branchMap)
 ->OBJ                            #OBJ.LINE_NUM:
                                  #  - total NUM: number of statements
                                  #  - covered NUM: number of executed statements
                                  #  - coverage NUM: total / covered * 100

COVMAP.data                       #Detailed multiple file coverage information
                                  #{ 'PATH': FILECOV }
ISTANBUL-LIB-COVERAGE.
 createCoverageMap
 ([COVMAP])->COVMAP               #
COVMAP.toJSON()->COVMAP.data      #
COVMAP.merge(COVMAP2)->COVMAP     #Calls each FILECOV.merge()
COVMAP.getCoverageSummary()
 ->SUMMARY                        #
COVMAP.files()->'PATH'_ARR        #
COVMAP.fileCoverageFor('PATH')
 ->FILECOV                        #
COVMAP.addFileCoverage
 (FILECOV|'PATH')                 #Merges if already existing
COVMAP.filter
 (FUNC(FILECOV)->BOOL)            #Deletes all FILECOV with BOOL false




                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OTHERS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT-SIDE TESTING ==>           #This was for server-side test. For client-side:
                                  #  - can use mocha-istanbul
                                  #  - or (easier) with karma-coverage:
                                  #     - preprocessors { SOURCE_FILE_GEXP: ["coverage"] ... }   //Instrument source code
                                  #     - reporter "coverage"                                    //Produce reports
                                  #     - CONFIGVAR coverageReporter:
                                  #        - OBJ: type FORMAT, dir DIR, file FILE, etc.
                                  #          Use DIR/BROWSER_VERSION_OS/FILE
                                  #        - or OBJ2: reporters OBJ_ARR for several different formats
                                  #  - and karma-threshold-reporter:
                                  #     - reporter "threshold" (after reporter "coverage" from karma-coverage)
                                  #     - CONFIGVAR thresholdReporter:
                                  #        - statements|branches|functions|lines NUM (e.g. 90)

gulp.src(SOURCE_FILES)
  .pipe(GULP-ISTANBUL([OBJ2]))
  .pipe
  (GULP-ISTANBUL.hookRequire())   #Several actions (version 0.6.0):
  .on("finish", function() {      #  - GULP-ISTANBUL() instrument the source files
    gulp.src(TEST_FILES)          #  - summarizeCoverage() produce an IOSTREAM of OBJ with members
      .pipe(GULP-MOCHA())         #    lines|statements|functions|branches OBJ2: total|covered|skipped|pct NUM
      .pipe(GULP-ISTANBUL.        #  - writeReports() produce reports with OBJ:
        summarizeCoverage()|      #     - dir DIR (def: "./coverage/")
        writeReports(OBJ))        #     - reporters ARR (def: ["lcov"])
      .on("end", FUNC())          #OBJ2:
  });                             #  - includeUntested BOOL: if true (def: false), include non-required modules

GULP-COFFEE-ISTANBUL              #Like GULP-ISTANBUL, but for CoffeeScript
                                  #Version 0.7.0

GULP-ISTANBUL-ENFORCER(OBJ)       #Do mocha check-coverage. OBJ:
                                  #  - thresholds OBJ: statements|branches|lines|functions NUM: --statements|etc.
                                  #  - coverageDirectory DIR: --dir
                                  #  - rootDirectory DIR: --rot
