
            
   ISTANBUL  
            





                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              NYC              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/



CONF                              #Can be:
                                  #  - package.json "nyc" CONF

nyc

--cwd                             #Used for:
                                  #  - CONF loading
                                  #Def: ENV NYC_CWD, or package root, or process.cwd()
--reporter|r 'FORMAT'             #Def: 'text'
--report-dir 'DIR'                #Def: 'coverage'
--silent|s                        #Def: false
--all|a                           #Def: false
--exclude|x ???                   #Def: TESTEXCLUDE.defaultExclude???
--exclude-after-remap             #Def: true
--include|n STR                   #Def: none
                                  #Can be done several times
--require|i STR                   #Def: none
                                  #Can be done several times
--eager                           #Def: false
--cache|c                         #Def: true
--babel-cache                     #Def: false
--extension|e '.EXT'              #Def: none
                                  #Can be done several times
--check-coverage                  #Def: false
--branches|functions|lines|
 statements NUM                   #Def: 0
--source-map                      #Def: true
--per-file                        #Def: false
--produce-source-map              #Def: false
--compact                         #Def: true
--preserve-comments               #Def: true
--instrument                      #Def: true
--hook-run-in-[this]-context      #Def: true
--show-process-tree               #Def: false
--clean                           #Def: true
--nycrc-path                      #Def: '.nycrc'
--temp-directory                  #Def: './.nyc-output'
--skip-empty                      #Def: false




                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         ISTANBUL-API          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISTANBUL-API ==>                  #1.3.2
                                  #Istanbul programmatic usage


CONF_OBJ                          #Plain object
CONF                              #CLASS
CONF.PROP()->VAL                  #Gets CONF_OBJ.PROP (camelCase instead of dasherized)

config.defaultConfig()->CONF_OBJ  #
config.loadObject
 ([CONF_OBJ], [CONF_OBJ2])->CONF  #CONF_OBJ has less priority than default one, CONF_OBJ2 has more
config.loadFile
 (['CONF_FILE'],[CONF_OBJ2])->CONF#Same with a YAML|JSON FILE (def: './.istanbul.yml')


instrument.cover                  #Target source files:
 (CONF[, 'GLOB'_ARR],             #  - including:
 FUNC(ERROR, COVER_OBJ))          #     - 'GLOB'_ARR
                                  #     - def: '**/*.EXT' using CONF.extensions '.EXT'_ARR (def: ['.js'])
                                  #  - excluding:
                                  #     - uses CONF.excludes (def: [])
                                  #     - adds ['**/node_modules|test|tests/**'] if CONF.defaultExcludes true (def)
                                  #     - adds CONF.reporting.dir 'DIR' (def: './coverage')
                                  #  - at CONF.instrumentation.root (def: '.')
                                  #  - unless CONF.includeAllSources true (def: false), do not report files that are never require()'d
COVER_OBJ.hookFn()                #Run ISTANBUL-LIB-HOOK.hookRequire(..., OPTS2)
                                  #  - with OPTS2:
                                  #     - extensions OPTS.extensions
                                  #     - verbose OPTS.verbose
                                  #     - coverageVariable '$$coverage$$'
                                  #  - that runs ISTANBUL-LIB-INSTRUMENT.createInstrumenter(OPTS2).instrumentSync() with OPTS2:
                                  #     - CONF.instrumentation OBJ (dasherized)
                                  #     - coverageVariable '$$coverage$$'
                                  #  - uses ISTANBUL-LIB-HOOK.hookRunIn[This]Context() instead if
                                  #    CONF.hooks.hookRunIn[This]Context true (def: false)
COVER_OBJ.unhookFn()              #Unhook and also run ISTANBUL-LIB-HOOK.unloadRequireCache()
COVER_OBJ.coverageFinderFn()      #Gets global.$$coverage$$ COVMAP
COVER_OBJ.exitFn(OPTS2)           #Gets global.$$coverage$$ COVMAP
                                  #Writes it at 'DIR/coverage[-PID].raw-json'
                                  #  - DIR is CONF.reporting.dir
                                  #  - PID if CONF.instrumentation.includePid true (def: false)
                                  #Apply MAPSTORE.transformCoverage(COVMAP):
                                  #  - uses returned sourceFinder as reporters' sourceFinder
                                  #  - instrumenter uses OPTS2.sourceMapUrlCallback MAPSTORE.registerURL()
                                  #Reports each COVMAP with createReporter() using 'FORMAT'_ARR:
                                  #  - CONF.reporting.reports 'FORMAT'_ARR (def: 'lcov')
                                  #  - 'text' and|or 'text-summary' according to CONF.reporting.print 'detail|summary|none|both' (def: 'summary')


instrument.run(CONF, OPTS, FUNC())#Instrument OPTS.input 'PATH':
                                  #  - using ISTANBUL-LIB-INSTRUMENT.createInstrumenter(OBJ).instrumentSync()
                                  #  - with CONF.instrumentation OBJ (dasherized)
                                  #     - coverageVariable is called variable (def: '__coverage__')
                                  #Then writes the result to OPTS.output 'PATH' (def: stdout)
                                  #Can use OPTS.input|output 'DIR':
                                  #  - OPTS.includes:
                                  #     - def ['**/*'] if CONF.completeCopy true (def: false)
                                  #     - otherwise [**/*.EXT] using CONF.extensions '.EXT'_ARR (def: ['.js'])
                                  #  - OPTS.excludes
                                  #     - uses CONF.excludes (def: [])
                                  #     - adds ['**/node_modules/**'] if CONF.defaultExcludes true (def)
                                  #If OPTS.saveBaseline true (def: false):
                                  #  - creates a COVEMAP with each INSTRUMENTER.lastFileCoverage() (i.e. empty counters)
                                  #  - saves it to to OPTS.baselineFile (def: './coverage/coverage-baseline.raw.json')


reports.run('FORMAT'_ARR, CONF    #Retrieves all COVMAP files using:
 [, OPTS], FUNC())                #  - OPTS.root 'DIR' (def: process.cwd())
                                  #  - OPTS.includes (def: '**/coverage*.raw.json')
                                  #  - excludes ['**/node_modules/**']
                                  #For each COVMAP, report it with createReporter()
createReporter(CONF[, OPTS])
 ->REPORTER                       #
REPORTER.addAll('FORMAT'_ARR)
REPORTER.add('FORMAT')            #Specify 'FORMAT'
REPORTER.write(COVMAP, OPTS2)     #Reports COVMAP with each 'FORMAT':
                                  #  - ISTANBUL-LIB-REPORT.createContext(OPTS2)->CONTEXT with OPTS2:
                                  #     - dir CONF.reporting.dir (def: './coverage')
                                  #     - watermarks CONF.reporting.watermarks (merged to default ones)
                                  #  - ISTANBUL-REPORTS.create('FORMAT', OPTS2)->VISITOR:
                                  #     - OPTS2 is CONF.reporting.report-config OBJ
                                  #  - TREE.visit(VISITOR, CONTEXT)
                                  #     - TREE is OPTS|CONF.summarizer 'flat|nested|pkg' (using ISTANBUL-LIB-REPORT.summarizers.*) (def: 'pkg')


checkCoverage(CONF[, OPTS],       #Find and merge COVMAP files:
 FUNC(ERROR|'ERROR'))             #  - OPTS.include (def: '**/coverage*.json')
                                  #  - at OPTS.root (def: CONF.instrumentation.root (def: '.'))
                                  #Check coverage (SUMMARY.*.pct) against CONF.check.global|each:
                                  #  - statements|branches|lines|functions NUM (def: 0)
                                  #  - excludes 'PATH'_ARR
                                  #  - global is for all files, each is for each file
                                  #If under thresholds: ERROR|'ERROR'


GLOBBING ==>                      #Uses node-fileset

filesFor                          #Find files
 ([OPTS], FUNC(ERROR, 'PATH'_ARR))#OPTS:
                                  #  - includes 'GLOB'_ARR (def: ['**/*.js'])
                                  #  - excludes 'GLOB'_ARR (def: ['**/node_modules/**'])
                                  #  - root 'DIR' (def: process.cwd())
                                  #  - relative BOOL (def: false): absolute|relative 'PATH'
                                  #  - realpath BOOL (def: false): resolve symlinks
matcherFor
 ([OPTS], FUNC(ERROR, FUNC2))     #Same but returns as FUNC2('/PATH')->BOOL


CONF.verbose                      #Debugging console.log()

CONF.postRequireHook???
CONF.handleSigint???



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:    ISTANBUL-LIB-INSTRUMENT    :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISTANBUL-LIB-INSTRUMENT ==>       #1.10.1
                                  #Instrument JavaScript code so it stores coverage information when run.

createInstrumenter([OPTS])        #OPTS:
 ->INSTRUMENTER                   #  - variable STR (def: '__coverage__')
INSTRUMENTER.instrumentSync       #In a nutshell:
 ('CODE'[, 'FILENAME'])->'CODE'   #  - set a global FILECOV (for this FILENAME) with source code's line|column|name information
                                  #  - add FILECOV.s|f|b.CID++ before each statement|function|branch
                                  #Instrument code:
                                  #  - prepends code that create a new FILECOV:
                                  #     - referenced by both global.__coverage__.FILENAME and a local variable
                                  #        - i.e. global.__coverage__ is a COVMAP
                                  #     - all FILECOV.statement|fn|branchMap.CID set to their related source code's line|column|name
                                  #     - all FILECOV.s|f|b.CID initialized to 0
                                  #  - adds counters:
                                  #     - FILECOV.s.CID++ before each statement
                                  #     - FILECOV.f.CID++ before each function
                                  #     - FILECOV.b.CID[INDEX]++ before each child branch
                                  #Do it by:
                                  #  - parsing JavaScript 'CODE' to AST (with Babylon, see its doc)
                                  #     - using options:
                                  #        - sourceType 'script' if OPTS.esModules false (def) or 'module'
                                  #        - plugins ['asyncGenerators', 'dynamicImport', 'objectRestSpread', 'flow', 'jsx']
                                  #        - allowReturnOutsideFunction OPTS.autoWrap BOOL (def: false)
                                  #  - traversing and transforming AST (with babel-traverse, see its doc)
                                  #     - can access only that logic using INSTANBUL-LIB-INSTRUMENT.ProgramVisitor
                                  #  - generating JavaScript 'CODE' from AST (with babel-generator, see its doc)
                                  #     - using options:
                                  #        - compact OPTS.compact BOOL (def: true): minify whitespaces
                                  #        - comments OPTS.preserveComments BOOL (def: false)
                                  #Noop if applied twice
                                  #Def 'FILENAME': 'TIMESTAMP.js'
INSTRUMENTER.instrument('CODE'
 [, 'FILENAME'], FUNC('CODE'))    #Same (is actually sync as well) but with different signature

INSTRUMENTER.lastFileCoverage()
 ->FILECOV                        #

INSTRUMENTER.lastSourceMap()      #Uses babel-generator options:
 ->SOURCE_MAP_OBJ                 #  - sourceMaps OPTS.produceSourceMap BOOL (def: false)
                                  #  - sourceFileName 'FILENAME'
                                  #To multi-map into an already existing SOURCE_MAP, add it as last argument to instrumentSync()
                                  #OPTS.sourceMapUrlCallback('FILENAME', 'sourceMappingURL') is called by instrumentSync() if defined
                                  #  - e.g. ISTANBUL-LIB-SOURCE-MAPS.registerURL

// istanbul ignore file [COMENT]  #Skip instrumentation for current file
// istanbul ignore next [COMENT]  #Skip instrumentation for next block|structure
// istanbul ignore if|else [CMT]  #Skip instrumentation for next if|else
OPTS.ignoreClassMethods           #Skip instrumentation for 'FUNC'_ARR

readInitialCoverage('CODE')->OBJ  #Returns (from already instrumented code):
                                  #  - coverageData FILECOV (with counters initialized to 0)
                                  #  - path 'FILENAME'
                                  #  - gcv '__coverage__'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     ISTANBUL-LIB-COVERAGE     :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISTANBUL-LIB-COVERAGE ==>         #Underlying data model for file coverage information
                                  #1.2.0

SUMMARY                           #Summarized single|multiple file[s] coverage information.
                                  #OBJ:
                                  #  - lines:
                                  #     - total NUM: lines executed or not
                                  #     - covered NUM: lines executed
                                  #     - skipped NUM: when using /* istanbul ignore */
                                  #     - pct NUM|'Unknown':
                                  #        - covered / total
                                  #        - 0-100 with 2 decimal digits precision
                                  #        - 100 if total 0
                                  #  - statements|functions|branches: same for statements|functions|branches
createCoverageSummary
 ([SUMMARY])->SUMMARY             #
SUMMARY.toJSON()->OBJ             #
SUMMARY.isEmpty()->BOOL           #SUMMARY.lines.total === 0
SUMMARY.merge(SUMMARY2)           #
 ->SUMMARY                        #Adds SUMMARY2's NUMs to SUMMARY

FILECOV                           #Detailed single file coverage information
                                  #OBJ:
                                  #  - path 'PATH'
                                  #  (number of times statement|function|branch was executed ("hits"))
                                  #  - s.CID NUM
                                  #  - f.CID NUM
                                  #  - b.CID NUM_ARR (each child branch)
                                  #  (line|column information and metadata)
                                  #  - statementMap.CID:
                                  #     - start|end.line|column NUM
                                  #  - fnMap.CID:
                                  #     - loc.start|end.line|column NUM: of the FUNC body
                                  #     - decl.start|end.line|column NUM: of the 'FUNC' name
                                  #     - name 'FUNC'
                                  #  - branchMap.CID:
                                  #     - loc.start|end.line|column NUM (the parent branch)
                                  #     - locations OBJ_ARR: start|end.line|column NUM (each child branch)
                                  #     - type 'if|switch|cond-expr|binary-expr|default-arg': type of node
                                  #       (IfStatement|SwitchStatement|ConditionalExpression|LogicalExpression|AssignmentPattern)
                                  #CID:
                                  #  - same statement|function|branch uses same CID between the counter and the *Map
                                  #  - incrementing 'NUM' for statement|function|branch
createFileCoverage
 (FILECOV|'PATH')->FILECOV        #
FILECOV.toJSON()->OBJ             #
FILECOV.merge(FILECOV2)->FILECOV  #Adds FILECOV2's NUMs to FILECOV
FILECOV.resetHits()               #Resets FILECOV.s|f|b to 0
FILECOV.toSummary()->SUMMARY      #Leaves SUMMARY.*.skipped to 0
                                  #Uses FILECOV.s|f|b
FILECOV.computeSimpleTotals
 ('getLineCoverage'|'s'|'f')
 ->SUMMARY.lines|statements|
 functions                        #
FILECOV.computeBranchTotals()
 ->SUMMARY.branches               #
FILECOV.getLineCoverage()         #Statements coverage (using FILECOV.s|statementMap)
 ->{ LINE_NUM: NUM }              #NUM is the number of times that line's statement was executed
                                  #If several statements, takes the max
FILECOV.getUncoveredLines()
 ->LINE_NUM_ARR                   #Same but only returns lines where no statement was executed
FILECV.getBranchCoverageByLine()  #Branch-wise statements coverage (using FILECOV.b|branchMap)
 ->OBJ                            #OBJ.LINE_NUM:
                                  #  - total NUM: number of statements
                                  #  - covered NUM: number of executed statements
                                  #  - coverage NUM: total / covered * 100

COVMAP.data                       #Detailed multiple file coverage information
                                  #{ 'PATH': FILECOV }
createCoverageMap
 ([COVMAP])->COVMAP               #
COVMAP.toJSON()->COVMAP.data      #
COVMAP.merge(COVMAP2)->COVMAP     #Calls each FILECOV.merge()
COVMAP.getCoverageSummary()
 ->SUMMARY                        #
COVMAP.files()->'PATH'_ARR        #
COVMAP.fileCoverageFor('PATH')
 ->FILECOV                        #
COVMAP.addFileCoverage
 (FILECOV|'PATH')                 #Merges if already existing
COVMAP.filter
 (FUNC(FILECOV)->BOOL)            #Deletes all FILECOV with BOOL false


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       ISTANBUL-LIB-HOOK       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISTANBUL-LIB-HOOK ==>             #1.2.0

hookRequire(FUNC('PATH')->BOOL,   #Monkey patches require():
 FUNC2(STR, { filename })->STR,   #  - applies FUNC2 first
 [OPTS])->FUNC3()                 #  - only if FUNC BOOL is true
                                  #  - do it by using deprecated require.extensions
                                  #FUNC3() disables it (but does not remove monkey patching)
                                  #OPTS:
                                  #  - extensions STR_ARR (def: ['.js'])
                                  #  - postLoadHook('FILENAME'): fired after each require()
                                  #  - verbose BOOL (def: false): debugging console.log()
unloadRequireCache(FUNC)          #Removes require.cache of files matching FUNC('PATH')->BOOL

hookCreateScript|                 #Same but using VM.createScript|runIn[This]Context() instead of hookRequire()
 runIn[This]Context(...)          #With runInContext():
                                  #  - sets GLOBAL.__coverage__ to reference of same empty OBJ in both current context and child context
                                  #  - can customnize '__coverage__' name using OPTS.coverageVariable
unhookCreateScript|
 runIn[This]Context()             #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:   ISTANBUL-LIB-SOURCE-MAPS    :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


INSTANBUL-LIB-SOURCE-MAPS ==>     #1.2.4
                                  #Modifies line|column numbers in coverage results by applying a source map

createSourceMapStore([OPTS])
 ->MAPSTORE                       #
MAPSTORE.transformCoverage(COVMAP)#Returns a new COVMAP2 with each FILECOV.inputSourceMap applied to each line|column number
 ->{ map COVMAP2, sourceFinder }  #Uses mozilla source-map's CONSUMER.originalPositionFor() (see its doc)

FILECOV.inputSourceMap            #SOURCE_MAP
MAPSTORE.registerMap
 ('PATH',SOURCE_MAP_OBJ)          #Alternative way instead of specifying FILECOV.inputSourceMap
MAPSTORE.registerURL('PATH', STR) #STR is sourceMappingURL value (base64 or external file)

MAPSTORE.sourceFinder             #If available, uses sourceContent:
 ('SOURCE_PATH')                  #  - cached during MAPSTORE.transformConverage() into OPTS.sourceStore:
 ->'FILE_CONTENT'                 #     - 'memory' (def)
                                  #     - 'file' at OPTS.tmpdir (def: OS.tmpdir())
                                  #Otherwise, reads the file:
                                  #  - relative to OPTS.baseDir 'DIR' (def: process.cwd())

MAPSTORE.dispose()                #Cleanup


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       ISTANBUL-REPORTS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISTANBUL-REPORTS ==>              #1.4.0
                                  #Reporters (based on ISTANBUL-LIB-REPORT)

create('FORMAT', OPTS)->VISITOR   #VISITOR which will produce report by using VISITOR.contentWriter
                                  #Common OPTS:
                                  #  - file 'FILENAME'
                                  #     - '-'|null for process.stdout
                                  #     - def 'FILENAME' is different for each FORMAT
VISITOR.contentWriter             #CONTENTWRITER to manually set

FORMAT 'none'                     #Nothing|silent

FORMAT 'json'                     #Like { 'PATH': FILECONV, ... } as JSON string
                                  #Def 'FILENAME': 'coverage-final.json'
FORMAT 'json-summary'             #{ 'PATH': SUMMARY, ..., total: SUMMARY } as JSON string
                                  #Def 'FILENAME': 'coverage-summary.json'

FORMAT 'text'                     #ASCII table with:
                                  #  - 'FILE' as lines
                                  #  - columns: SUMMARY.lines|statements|functions|branches.pct NUM, FILECOV.getUncoveredFiles()
                                  #Def 'FILENAME': null
                                  #OPTS:
                                  #  - maxCols NUM (def: 0)
                                  #  - skipEmpty BOOL (def: false): skip empty files
FORMAT 'text-summary'             #SUMMARY.lines|statements|functions|branches.pct NUM for all files
                                  #Def 'FILENAME': null

FORMAT 'html'                     #Similar to 'text' but as HTML
                                  #OPTS:
                                  #  - subdir 'DIR': output sub-'DIR'
                                  #  - skipEmpty BOOL (def: false): skip empty files
                                  #  - linkMapper OBJ: customize URLs by mapping them
                                  #  - verbose BOOL (def: false): debugging console.log()

FORMAT 'lcovonly'                 #LCOV (see its doc)
                                  #Def 'FILENAME': 'lconv.info'
FORMAT 'lcov'                     #lcovonly + html
FORMAT 'text-lcov'                #Like lcovonly file OPTS.file '-'

FORMAT 'teamcity'                 #Teamcity's format
                                  #Def 'FILENAME': null
                                  #OPTS: blockName STR (def: 'Code Coverage Summary')
FORMAT 'clover'                   #Atlassian clover's format
                                  #Def 'FILENAME': 'clover.xml'
                                  #OPTS: projectRoot 'DIR' (def: process.cwd())
FORMAT 'cobertura'                #Cobertura's format
                                  #Def 'FILENAME': 'cobertura-coverage.xml'
                                  #OPTS: projectRoot 'DIR' (def: process.cwd())


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      ISTANBUL-LIB-REPORT      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISTANBUL-LIB-REPORT ==>           #1.1.4
                                  #Base helpers for reporters:
                                  #  - FILEWRITER: writing to file|console, raw or XML
                                  #  - summarizers|TREE: organizing and visiting FILECOVs as a tree
                                  #  - few utilities (e.g. watermarks)


createContext([OPTS])->CONTEXT    #

CONTEXT.getWriter()->FILEWRITER   #Uses OPTS.dir 'DIR' (def: 'coverage') to resolve 'PATH'
FILEWRITER.writeFile('PATH')      #Write to file at 'DIR/PATH', where 'DIR' is OPTS.dir (def: 'coverage')
 ->CONTENTWRITER                  #If 'PATH' '-'|null, use CONSOLEWRITER instead:
                                  #  - same methods as CONTENTWRITER but writes on process.stdout
FILEWRITER.writerForDir('DIR')
 ->FILEWRITER                     #Prepends to OPTS.dir
FILEWRITER.copyFile
 ('PATH2', 'PATH')                #Same as writeFile() but using 'PATH2' content

CONTENTWRITER.write(STR)
CONTENTWRITER.println(STR)        #Same as write('STR\n')
CONTENTWRITER.close()

CONSOLEWRITER.colorize
 (STR, 'low|medium|high')->STR    #Make green|orange|red (only if SUPPORTS-COLORS (see Chalk doc))
CONSOLEWRITER.start|stopCapture() #Buffers to memory instead of writing to process.stdout
CONSOLEWRITER.getOutput()->STR    #Output that buffers
CONSOLEWRITER.resetOutput()->STR  #Reset that buffers

CONTEXT.getXMLWriter(CONTENTWRITR)
 ->XMLWRITER                      #CONTENTWRITER specialized for XML
XMLWRITER.openTag('TAG',ATTRS_OBJ)#
XMLWRITER.closeTag('TAG')         #
XMLWRITER.inlineTag
 ('TAG', ATTRS_OBJ, STR)          #
XMLWRITER.indent(STR)             #
XMLWRITER.closeAll()              #


summarizers.flat(COVMAP)->TREE    #TREE where root is empty REPORT_NODE, and all FILECOVs are children
                                  #I.e. depth level is 2

summarizers.nested(COVMAP)->TREE  #TREE where FILECOVs are structured according to their filepaths

summarizers.pkg(COVMAP)->TREE     #Like summarizers.nested() except directories are nested inside each other.
                                  #Instead they are all children of root, i.e. max depth level is 3

TREE                              #Tree of REPORT_NODE
TREE.getRoot()->REPORT_NODE       #
TREE.visit(VISITOR, STATE)        #Recurse over root and its children
                                  #Calls VISITOR:
                                  #  - onStart(REPORT_NODE, STATE): root beginning
                                  #  - onDetail(REPORT_NODE, STATE): each non-summary node (before children)
                                  #  - onSummary[End](REPORT_NODE, STATE): each summary node (before|after children)
                                  #  - onEnd(REPORT_NODE, STATE): root end

REPORT_NODE                       #Represents a FILECOV or a single file's SUMMARY
REPORT_NODE.addChild(REPORT_NODE2)#
REPORT_NODE.getParent()
 ->REPORT_NODE2|null              #
REPORT_NODE.getFileCoverage()
 ->FILECOV                        #FILECOV or (if SUMMARY) undefined
REPORT_NODE.getCoverageSummary    #If:
 ([BOOL])->SUMMARY                #  - FILECOV defined: FILECOV.toSummary()
                                  #  - otherwise:
                                  #     - new SUMMARY by recursing over children
                                  #     - unless BOOL true, also merge children that are SUMMARY2 themselves
                                  #Cached
REPORT_NODE.isSummary()->BOOL     #True if no FILECOV
REPORT_NODE.path                  #'PATH'
REPORT_NODE.getQualifiedName()
 ->'PATH'                         #
REPORT_NODE.getRelativeName()
 ->'NAME'                         #


CONTEXT.classForPercent           #Returns whether NUM is 'low|medium|high' according to watermarks:
 (CATEGORY, NUM)->STR2            #  - CATEGORY (statements|lines|functions|branches)
                                  #     - [NUM, NUM2]
                                  #     - def: [50, 80]
                                  #  - can override with OPTS.watermarks.CATEGORY [NUM, NUM2]
getDefaultWatermarks()->OBJ       #


CONTEXT.getSource('PATH')->STR    #Runs either:
                                  #  - FS.readFileSync()
                                  #  - OPTS.sourceFinder('PATH')->STR if defined
                                  #     - e.g. the one from INSTANBUL-LIB-SOURCE-MAPS to get source file's content,
                                  #       not compiled file


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     BABEL-PLUGIN-ISTANBUL     :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


VERSION ==>                      ##4.1.6
                                 ##Babel plugin that instrument code with Istanbul (ISTANBUL-LIB-INSTRUMENT)

PLUGIN_OPTS.useInlineSourceMaps  ##BOOL (def: true)
PLUGIN_OPTS.onCover
 (FUNC('PATH', FILECOV))         ##Optional event handler






                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            FORMER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/



VERSION ==>                       #0.3.0
                                  #JavaScript test coverage generation


CONF ==>                          #Can be:
                                  #  - ./.istanbul.json|yml
                                  #  - --config FILE.json|yml
CONF.instrumentation.*            #CONFI
CONF.reporting.*                  #CONFR.


coverage.json                     #Low-level machine-friendly coverage output

istanbul instrument FILE.js ...   #Generates test coverage (coverage.json) by running FILE.js ...
istanbul instrument DIR...        #Same but for DIR/**/.js and generating in --output DIR2

CONFI.root DIR
--root DIR                        #Root DIR of files to cover (def: '.')
CONFI.excludes STR_ARR
-x FILE...                        #Exclude files
CONFI.default-excludes BOOL
--[no-]default-excludes           #Default excluded files to cover (def: '**/node_modules|test[s]/**')

CONFI.save-baseline BOOL
--save-baseline                   #Save to --baseline-file FILE instead of only stdout
CONFI.baseline-file FILE
--baseline-file FILE              #Def: './coverage/coverage-baseline.json'

CONFI.embed-source BOOL
--embed-source                    #Embed JavaScript source code in coverage.json (def: false)
CONFI.complete-copy BOOL
--complete-copy                   #Embed non JavaScript source code in coverage.json (def: false)
CONFI.compact BOOL
--no-compact                      #Don't minimize output


istanbul report [OPTS]
[FORMAT [FILE...]]                #Turn coverage.json FILE... (def: **/coverage*.json) into FORMAT

CONFR.dir DIR
--dir DIR                         #Output DIR (def: './coverage/')
--root DIR                        #Prepended to FILE...

CONFR.reports OBJ
--report FORMAT                   #

CONFR.print STR                   #What to print on terminal among:
--print STR                       #  - summary
                                  #  - detail
                                  #  - both
                                  #  - none
CONF.verbose BOOL
-v                                #



istanbul cover FILE.js ...        #istanbul instrument + instanbul report
                                  #Same options
istanbul test FILE.js ...         #Like istanbul cover except only do something if ENVVAR npm_config_coverage is set
                                  #(i.e. npm run SCRIPT --coverage)



istanbul check-coverage
--statements|functions|           #Exit code 1 if coverage < PERCENT
branches|lines PERCENT [FILE...]  #Do so by looking at coverage.json FILE... (def: '**/coverage*.json')
CONFR.watermarks.statements|
 lines|functions|branches
 [PERCENT, PERCENT2]              #PERCENT is error, PERCENT2 is warning



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OTHERS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT-SIDE TESTING ==>           #This was for server-side test. For client-side:
                                  #  - can use mocha-istanbul
                                  #  - or (easier) with karma-coverage:
                                  #     - preprocessors { SOURCE_FILE_GEXP: ["coverage"] ... }   //Instrument source code
                                  #     - reporter "coverage"                                    //Produce reports
                                  #     - CONFIGVAR coverageReporter:
                                  #        - OBJ: type FORMAT, dir DIR, file FILE, etc.
                                  #          Use DIR/BROWSER_VERSION_OS/FILE
                                  #        - or OBJ2: reporters OBJ_ARR for several different formats
                                  #  - and karma-threshold-reporter:
                                  #     - reporter "threshold" (after reporter "coverage" from karma-coverage)
                                  #     - CONFIGVAR thresholdReporter:
                                  #        - statements|branches|functions|lines NUM (e.g. 90)

gulp.src(SOURCE_FILES)
  .pipe(GULP-ISTANBUL([OBJ2]))
  .pipe
  (GULP-ISTANBUL.hookRequire())   #Several actions (version 0.6.0):
  .on("finish", function() {      #  - GULP-ISTANBUL() instrument the source files
    gulp.src(TEST_FILES)          #  - summarizeCoverage() produce an IOSTREAM of OBJ with members
      .pipe(GULP-MOCHA())         #    lines|statements|functions|branches OBJ2: total|covered|skipped|pct NUM
      .pipe(GULP-ISTANBUL.        #  - writeReports() produce reports with OBJ:
        summarizeCoverage()|      #     - dir DIR (def: "./coverage/")
        writeReports(OBJ))        #     - reporters ARR (def: ["lcov"])
      .on("end", FUNC())          #OBJ2:
  });                             #  - includeUntested BOOL: if true (def: false), include non-required modules

GULP-COFFEE-ISTANBUL              #Like GULP-ISTANBUL, but for CoffeeScript
                                  #Version 0.7.0

GULP-ISTANBUL-ENFORCER(OBJ)       #Do mocha check-coverage. OBJ:
                                  #  - thresholds OBJ: statements|branches|lines|functions NUM: --statements|etc.
                                  #  - coverageDirectory DIR: --dir
                                  #  - rootDirectory DIR: --rot
