
             
   TESTCHECK  
             



ALTERNATIVES ==>                  #  - testckeck-js
                                  #     - run a function several times, each time with different generated input (within specific constraints)
                                  #     - tries to guess upper and lower limit of generated input that make tests fail
                                  #  - sazerac:
                                  #     - not maintained
                                  #     - more expressive syntax for running the same test several times with different output
                                  #        - although using ARR.forEach(VAL => it(...)) is actually simpler and better

VERSION ==>                       #1.0.0-rc.2

GEN                               #Abstraction of a FUNC()->VAL for a specific type|constraints
                                  #Actually an OBJ not a FUNC
                                  #First generated values are:
                                  #  - towards to the middle of the values domain
                                  #  - then expand in both directions after each run
                                  #  - e.g. gen.int: 0, 5, -5, 10, -10, etc.
                                  #Can be any of TESTCHECK.gen.*

TESTCHECK.gen.deepCopyOf(VAL)     #Can be used as GEN
VAL                               #Always generates VAL (by deep copy)
TESTCHECK.gen.return(VAL)         #Always generates VAL (by reference)

TESTCHECK.gen.boolean             #BOOL

TESTCHECK.gen.undefined           #undefined
TESTCHECK.gen.null                #null

TESTCHECK.gen.intWithin(NUM, NUM2)#Integer between NUM and NUM2
TESTCHECK.gen.int                 #Integer between -100 and 100
TESTCHECK.gen.posInt              #Integer between 0 and 100
TESTCHECK.gen.sPosInt             #Integer between 1 and 100
TESTCHECK.gen.negInt              #Integer between -100 and -0
TESTCHECK.gen.sNegInt             #Integer between -100 and -1

TESTCHECK.gen.numberWithin
 (NUM, NUM2)                      #Float between NUM and NUM2
TESTCHECK.gen.number              #Float between Number.MIN_VALUE and Number.MAX_VALUE.
                                  #Also generates NaN, Infinity, -Infinity
TESTCHECK.gen.posNumber|negNumber #Same but only positive|negative
TESTCHECK.gen.NaN                 #NaN

TESTCHECK.gen.char                #Single STR character
                                  #Generates backslash sequences either as sequences or as is
TESTCHECK.gen.asciiChar           #[[:print:]]
TESTCHECK.gen.alphaNumChar        #[[:alnum:]]
TESTCHECK.gen.string
TESTCHECK.gen.asciiString         #Same as a string
TESTCHECK.gen.alphaNumString      #String length uses TESTCHECK.gen.posInt (i.e. can be empty string)

TESTCHECK.gen.substring(STR)      #Random STR.substring(...)

TESTCHECK.gen.array(GEN[, NUM])   #Array length uses TESTCHECK.gen.posInt (i.e. can be empty)
TESTCHECK.gen.uniqueArray
 (GEN[, NUM])                     #Same but every ARR element is unique

TESTCHECK.gen.object([GEN, ]GEN2) #Object with:
                                  #  - key GEN (def: TESTCHECK.gen.alphaNumString)
                                  #  - value GEN2
                                  #  - length TESTCHECK.gen.posInt (i.e. can be empty)

TESTCHECK.gen.oneOf(GEN_ARR)      #Random pick a GEN
TESTCHECK.gen.oneOfWeighted
 ([WEIGHT_NUM, GEN]_ARR)          #Same but weighted
TESTCHECK.gen.nested(GEN, GEN2)   #Either GEN(GEN2) or GEN(GEN(GEN2)) or ...

TESTCHECK.gen.arrayOrObject(GEN)  #Like TESTCHECK.gen.oneOf(TESTCHECK.gen.array(GEN), TESTCHECK.gen.object(GEN))
TESTCHECK.gen.primitive           #Either TESTCHECK.gen.null|undefined|integer|number|string
TESTCHECK.gen.JSONPrimitive       #Either TESTCHECK.gen.null|integer|number|string (excluding NaN|[-]Infinity)
TESTCHECK.gen.JSONValue           #Like TESTCHECK.gen.nested(TESTCHECK.gen.arrayOrObject, TESTCHECK.gen.JSONPrimitive)
TESTCHECK.gen.JSON                #Like TESTCHECK.gen.nested(TESTCHECK.gen.object, TESTCHECK.gen.JSONValue)
TESTCHECK.gen.any                 #Like TESTCHECK.gen.nested(TESTCHECK.gen.arrayOrObject, TESTCHECK.gen.primitive)

TESTCHECK.gen.sized               #GEN which is constructed using a NUM
 (FUNC(NUM)->GEN)                 #Declaratively doing so allow GEN to be known to be "sized", which is used during binary search
                                  #All builtin GEN are "sized"

TESTCHECK.sampleOne(GEN)->VAL     #Returns one generated value
TESTCHECK.sample(GEN[, NUM])->ARR #Returns NUM (def: 10) generated values

TESTCHECK.property
 (GEN..., FUNC(VAL...)->BOOL)     #Abstraction of a FUNC that take generated VAL... as input and returns BOOL
 ->PROP                           #If FUNC() returns non-BOOL, it will be considered true

TESTCHECK.check(PROP[, OPTS])     #Runs a PROP several times and reports RESULT
 ->RESULT                         #At first PROP's FUNC returning false, try to guess which generated value is the problem limit:
                                  #  - by running the test doing a binary search
                                  #  - those extra tests are performed until limit is found
                                  #  - with several generated values, first try to guess which one is problematic
                                  #OPTS:
                                  #  - numTests NUM (def: 100): number of tests to run
                                  #  - seed NUM: randomness seed
                                  #RESULT:
                                  #  - result BOOL: true if no PROP's FUNC returned false
                                  #  - seed NUM
                                  #  - numTests NUM:
                                  #     - number of tests run
                                  #     - might be lower if result false
                                  #     - does not take binary search into account
                                  #  (if results false)
                                  #  - failingSize NUM: numTests - 1
                                  #  - fail ARR: generated values that triggered the failed test
                                  #  - shrunk:
                                  #     - totalNodesVisited NUM: number of binary search tests
                                  #     - smallest ARR: result of the binary search
