
            
   NODE_TAP  
            



VERSION ==>                       #12.0.1

tap FILE...                       #
--cov
--coverage-report=FORMAT

CHECK CHILD TAP OUTPUT WORKS WITH REPORTERS???

TAP                               #Is also a TEST except:
                                  #  - piped to stdout
                                  #  - some extra properties???
                                  #  - process 'exit' event handler???
                                  #  - autoend true if there is tearDown???
new Test(...)

TEST                              #Is an ISTREAM, piped to their parent

TEST.test(['TEST_TITLE', ][TOPTS, ][FUNC(TEST2)])->PROMISE_TEST
                                  #Def 'TEST_TITLE': FUNC.name, or '(unnamed test)'
                                  #If no FUNC: like TOPTS.todo true
                                  #Exceptions in FUNC or rejected PROMISE make test fail???
                                  #  - what's the TAP output???
                                  #  - does that mean other assertion libraries can be used???
TEST.end()                        #Automatically done when test's FUNC() return a PROMISE
TEST.plan(NUM)                    #Automatically calls TEST.end() after NUM assertions
                                  #Make test fail if wrong assertions count
TOPTS.autoend                     #BOOL. Automatically call TEST.end() on next microtask
                                  #Def: false unless TEST.tearDown() defined

TOPTS.timeout                     #NUM (def: none???)

TOPTS.bail                        #BOOL (def: false): stop all tests on first test failure
TEST.bailout([STR])               #Stops all tests

TEST.tearDown(FUNC())             #Called after TEST.end()
TEST.beforeEach|afterEach         #Called before|after each child
 (FUNC([FUNC2]))                  #Async: FUNC2([ERROR]) or return PROMISE

TOPTS.buffered                    #BOOL (def: TOPS.jobs > 1): whether TAP child is buffered or not (see TAP format doc)
                                  #Can also use ENVVAR TAP_BUFFER=0|1
                                  #If not buffered, child will be output before its parent

--jobs|j NUM                      #Are executed out of order, but are buffered so they remain in order in the output
TEST|TOPTS.jobs NUM               #CPU parallelism or I/O parallelism???
                                  #With CLI, if an empty file named 'test-parallel-[not-]ok' exists, use it to enable|disable
                                  #parallelism on all sibling files recursively

TEST.todo(...)
TOPTS|AOPTS.todo BOOL             #Pending test

TEST.skip(...)
TOPTS|AOPTS.skip BOOL             #Skipped test

--grep|g REGEXP                   #Only include tests with matching title
TEST|TOPTS.grep REGEXP_ARR        #Other tests are marked as skipped in TAP output:
ENVVAR TAP_GREP 'REGEXP\n...'     #  - directive # SKIP filter: /REGEXP/ after the test
                                  #  - comment # skip: NUM at end of the parent

--invert|i
ENVVAR TAP_GREP_INVERT 1|0        #Inverts --grep

TEST|TOPS.runOnly BOOL            #Must be set for the following to work
                                  #Not recursive
--only
TAP_ONLY 1|0                      #Same as setting TAP.runOnly BOOL
TEST.only(...)                    #Only run that test
TEST|TOPTS.only BOOL              #Use directive # SKIP filter: only and comment # skip: NUM like --grep

TEST.comment(STR)                 #TAP comment

TEST.pragma({ VAR: BOOL, ... })   #TAP pragma

TAP's YAML ERROR PROPERTIES ==>   #  - at STR, stack STR: using (new Error).stack
TOPTS.AOPTS.diagnostic            #BOOL (def: false): set YAML error properties even if assertion passes

TEST.*(...[, 'ASSERT_TITLE'][, AOPTS])
                                  #Can be passed for all assertion functions
                                  #Def 'ASSERT_TITLE':
                                  #  - TEST.throws(): ERROR.message ???
TEST.*()->BOOL                    #All assertion functions either:
                                  #  - return true (or PROMISE for TEST.resolve*|rejects())
                                  #  - throw error???
TEST.passing()->BOOL ???

DURATION ==>                      #Added as a DIRECTIVE # time=NUMms to each assertion that has children
                                  #Added as a comment # time=NUMms at end of each test

Test are run on same microtask they are defined???

TEST.pass()                       #
TEST.fail()                       #

TEST.equal(VAL, VAL2)             #===
                                  #Aliases: TEST.equals|isEqual|is|strictEqual[s]|strictIs|isStrict[ly]()
TEST.notEqual(VAL, VAL2)          #!==
                                  #Aliases: TEST.notEquals|isNotEqual|doesNotEqual|[is]inequal|isNot|notStrictEqual[s]()
TEST.strictSame(VAL, VAL2)        #Deep ===
                                  #Aliases: TEST.strictDeepEqual[s]|strictEquivalent|sameStrict|deepIs|isDeep[ly]()
TEST.strictNotSame(VAL, VAL2)     #Deep !==
                                  #Aliases: TEST.strictInequivalent|strictDeepInequal[s]|notSameStrict|deepNot|notDeeply|notStrictSame()
TEST.same(VAL, VAL2)              #Deep ==
                                  #Aliases: TEST.deepEqual[s]|looseEqual[s]|equivalent|isLoose|looseIs()
TEST.notSame(VAL, VAL2)           #Deep !=
                                  #Aliases: TEST.notLoose|looseNot|notDeep|inequivalent|looseInequal|deepInequal()

TEST.error(ERROR)                 #instanceof Error
                                  #Aliases: TEST.ifErr[or]()

TEST.ok(VAL)                      #== true
                                  #Aliases: TEST.true|assert()
TEST.notOk(VAL)                   #== false
                                  #Aliases: TEST.false|assertNot()

TEST.match(VAL, VAL2)             #Deep ==
                                  #Aliases: TEST.has[Fields]|matches|similar|[is]like|include[s]|contains()
TEST.match(OBJ, OBJ2)             #Deep TEST.match()
TEST.notMatch(VAL, VAL2)          #Inverse of TEST.match()
                                  #Aliases: TEST.[is]dissimilar|unsimilar|[is]notSimilar|[is]unlike|[is]notLike|doesNotHave()

TEST.match(VAL, TYPE)             #instanceof TYPE (can use String|Boolean|... for simple types)
TEST.type                         #typeof VAL === 'TYPEOF' || instanceof TYPE|'TYPE'
 (VAL, 'TYPEOF'|'TYPE'|TYPE)      #Aliases: TEST.isA()

TEST.match(STR, REGEXP)           #REGEXP.test()
TEST.match(STR, STR2)             #STR.includes(STR2)


TEST.throws(FUNC[, VAL])          #FUNC() throws, and TEST.match(ERROR, VAL)
                                  #Check detail of this ???
                                  #Aliases: TEST.throw()
TEST.doesNotThrow(FUNC[, VAL])    #Inverse
                                  #Aliases: TEST.notThrow()

TEST.rejects(PROMISE[()][, VAL])  #PROMISE rejected with VAL2, and TEST.match(VAL2, VAL)
TEST.resolveMatch
 (PROMISE[()][, VAL])             #PROMISE resolved with VAL2, and TEST.match(VAL2, VAL)
TEST.resolves(PROMISE[()])        #PROMISE resolved
