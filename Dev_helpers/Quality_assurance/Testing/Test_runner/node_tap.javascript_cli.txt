
            
   NODE_TAP  
            



VERSION ==>                       #12.0.1

CONFIG ==>                        #Can be:
                                  #  - ENVVAR TAP_RCFILE YAML_FILE
                                  #  - ~/.taprc YAML_FILE
                                  #  - tap --FLAG
                                  #Can be created from tap ... --dump-config

tap [FILE...]                     #FILE can be - (for stdin, def)

--test-arg=ARG                    #Pass CLI argument to each node FILE ...
                                  #Can be done several times

--node-arg=FLAG                   #Pass node --FLAG
                                  #Can be done several times
--[expose-]gc
--debug[-brk]
--harmony
--strict                          #Same for those FLAGs

--[no-]cov[erage]                 #Using nyc
--[no-]coverage-report=FORMAT     #Def: 'text'
--no-browser                      #Unless set, --coverage-report=html will open browser afterwards
--nyc-arg=ARG                     #Pass CLI argument to nyc ...
                                  #Can be done several times
--check-coverage
--branches|functions|lines|
 statements NUM                   #Specific nyc arguments
--100                             #Same as --branches|functions|lines|statements 100

--color|c
--no-color|C
ENVVAR TAP_COLORS=0|1             #

--output|o FILE                   #Def: stdout
--reporter|R FORMAT               #Pipe TAP output to reporter among:
																	#  - classic
																	#  - doc
																	#  - dot
																	#  - dump
																	#  - json
																	#  - jsonstream
																	#  - landing
																	#  - list
																	#  - markdown
																	#  - min
																	#  - nyan
																	#  - progress
																	#  - silent
																	#  - spec
																	#  - tap
																	#  - xunit
                                  #Uses tap-mocha-reporter???
ENVVAR TAP=1                      #Ignore --reporter

--save|s FILE                     #FILE is a newline-separated list of FILE2... to run
                                  #If some tests fail, it will written to FILE, i.e. next run will only re-test failed tests.

CHECK CHILD TAP OUTPUT WORKS WITH PARSERS AND REPORTERS???

TAP                               #Is also a TEST except:
                                  #  - piped to stdout
                                  #  - some extra properties???
                                  #  - process 'exit' event handler???
new Test(...)

TEST                              #Is an ISTREAM, piped to their parent

TEST.test(['TEST_TITLE', ][TOPTS, ][FUNC(TEST2)])->PROMISE_TEST
                                  #Def 'TEST_TITLE': FUNC.name, or ''
                                  #If no FUNC: like TOPTS.todo true
                                  #Exceptions in FUNC or rejected PROMISE make test fail???
                                  #  - what's the TAP output???
                                  #  - does that mean other assertion libraries can be used???
TEST.end()                        #Automatically done when test's FUNC() return a PROMISE
TEST.plan(NUM[, 'COMMENT'])       #Automatically calls TEST.end() after NUM assertions
                                  #Make test fail if wrong assertions count
TEST|TOPTS.autoend                #BOOL. Automatically call TEST.end() on next microtask
                                  #Def: false except on TAP when TAP.tearDown() is defined
TEST.endAll()                     #Call TEST.end() on all children then itself

mocha.describe|context(...)       #Same as TEST.test(...) except using FUNC()???
mocha.it(...)                     #Same as TEST.test(...) except using FUNC([FUNC2])???
mocha.before|after(...)           #beforeAll|afterAll()
mochaGlobals()                    #Assign mocha.* to global.*

--timeout|t NUM
--no-timeout|T
TOPTS.timeout NUM                 #In seconds. Def: 30
ENVVAR TAP_TIMEOUT NUM            #0 to disable

--bail|b
--no-bail|B
ENVVAR TAP_BAIL=0|1
TOPTS.bail                        #BOOL (def: false): stop all tests on first test failure
TEST.bailout(['COMMENT'])         #Stops all tests

TEST.tearDown(FUNC())             #Called after TEST.end()
TEST.beforeEach|afterEach         #Called before|after each child
 (FUNC([FUNC2]))                  #Async: FUNC2([ERROR]) or return PROMISE

TOPTS.buffered                    #BOOL (def: TOPS.jobs > 1): whether TAP child is buffered or not (see TAP format doc)
ENVVAR TAP_BUFFER=0|1             #If not buffered, child will be output before its parent
                                  #Must be true if TOP.jobs > 1

--jobs|j NUM                      #Are executed out of order, but are buffered so they remain in order in the output
TEST|TOPTS.jobs NUM               #CPU parallelism or I/O parallelism???
                                  #With CLI, if an empty file named 'test-parallel-[not-]ok' exists, use it to enable|disable
                                  #parallelism on all sibling files recursively
                                  #Only for test children, but not descendants???
--jobs-auto|J                     #Same as --jobs NUMBER_OF_CPUS ???

TEST RUN ==>                      #Test functions are run as they are defined (i.e. synchronously)

new Spawn(...) ???
TEST.spawn(..., 'TEST_TITLE')     #Uses CHILD_PROCESS.spawn(...) as TAP input for this TEST
 ->PROMISE_TEST                   #Can specify TOPTS.* in spawn() OPTS

new Stdin(...) ???
TEST.stdin()->PROMISE_TEST        #Use stdin as TAP input for this TEST

TEST.todo(...)
TOPTS|AOPTS.todo BOOL             #Pending test

TEST.skip(...)
TOPTS|AOPTS.skip BOOL             #Skipped test

--grep|g REGEXP                   #Only include tests with matching title
TEST|TOPTS.grep REGEXP_ARR        #Other tests are marked as skipped in TAP output:
ENVVAR TAP_GREP 'REGEXP\n...'     #  - directive # SKIP filter: /REGEXP/ after the test
                                  #  - comment # skip: NUM at end of the parent

--invert|i
ENVVAR TAP_GREP_INVERT 1|0        #Inverts --grep

TEST|TOPS.runOnly BOOL            #Must be set for the following to work
                                  #Not recursive
--only|O
TAP_ONLY 1|0                      #Same as setting TAP.runOnly BOOL
TEST.only(...)                    #Only run that test
TEST|TOPTS.only BOOL              #Use directive # SKIP filter: only and comment # skip: NUM like --grep

TEST.comment(STR)                 #TAP comment

TEST.pragma({ VAR: BOOL, ... })   #TAP pragma
                                  #Including pragma strict (see TAP-PARSER doc)

TAP OUTPUT ==>                    #  - TAP version 13
                                  #  - DIRECTIVEs: TODO|SKIP
                                  #  - '- ' prepended to all 'ASSERT_TITLE'
                                  #  - TEST.test(): assertion with children
                                  #     - use # Subtest: TEST_TITLE
                                  #  - plan 1..NUM [# COMMENT]
                                  #  - Bail out!

DURATION ==>                      #Added as a DIRECTIVE # time=NUMms to each assertion that has children
                                  #Added as a comment # time=NUMms at end of each test

TAP'S YAML ERROR PROPERTIES ==>   #  - at STR, stack STR: using (new Error).stack
                                  #  - source STR: source line of code
                                  #  - found|wanted VAL|VAL2 (expected|actual): with all but TEST.pass|fail|threw()
TOPTS|AOPTS.diagnostic BOLL
ENVVAR TAP_DIAG=0|1               #Set YAML error properties even if assertion passes

EXCEPTIONS ==>                    #Assertions only report: they do not throw (i.e. control flow continues)

TEST.*()->BOOL                    #All assertions return BOOL (or PROMISE for TEST.resolve*|rejects())
TEST.passing()->BOOL              #False if a previous assertion has failed

EXCEPTION HANDLING ==>            #Thrown exceptions make test fail using TEST.threw(), but are not propagated
                                  #They throw a deprecation warning from Node.js (because they use DOMAINs)

TEST.*                            #Can be passed for all assertion functions
 (...[, 'ASSERT_TITLE'][, AOPTS]) #Def 'ASSERT_TITLE':
                                  #  - TEST.pass|fail|skip(): '(unnamed test)'
                                  #  - TEST.threw|error(): ERROR.message
                                  #  - others: 'should|expect ...'

TEST.pass()                       #
TEST.fail()                       #
TEST.threw(ERROR)                 #Like TEST.fail() but using information from ERROR:
                                  #  - 'ASSERT_TITLE': ERROR.message
                                  #  - stack|at|source: ERROR.stack
                                  #  - any ERROR.*: as is (stringified with UTIL.inspect())

TEST.equal(VAL, VAL2)             #===
                                  #Aliases: TEST.equals|isEqual|is|strictEqual[s]|strictIs|isStrict[ly]()
TEST.notEqual(VAL, VAL2)          #!==
                                  #Aliases: TEST.notEquals|isNotEqual|doesNotEqual|[is]inequal|isNot|notStrictEqual[s]()
TEST.strictSame(VAL, VAL2)        #Deep ===
                                  #Aliases: TEST.strictDeepEqual[s]|strictEquivalent|sameStrict|deepIs|isDeep[ly]()
TEST.strictNotSame(VAL, VAL2)     #Deep !==
                                  #Aliases: TEST.strictInequivalent|strictDeepInequal[s]|notSameStrict|deepNot|notDeeply|notStrictSame()
TEST.same(VAL, VAL2)              #Deep ==
                                  #Aliases: TEST.deepEqual[s]|looseEqual[s]|equivalent|isLoose|looseIs()
TEST.notSame(VAL, VAL2)           #Deep !=
                                  #Aliases: TEST.notLoose|looseNot|notDeep|inequivalent|looseInequal|deepInequal()

TEST.error(ERROR)                 #instanceof Error
                                  #Aliases: TEST.ifErr[or]()

TEST.ok(VAL)                      #== true
                                  #Aliases: TEST.true|assert()
TEST.notOk(VAL)                   #== false
                                  #Aliases: TEST.false|assertNot()

TEST.match(VAL, VAL2)             #Deep ==
                                  #Aliases: TEST.has[Fields]|matches|similar|[is]like|include[s]|contains()
TEST.match(OBJ, OBJ2)             #Deep TEST.match()
TEST.notMatch(VAL, VAL2)          #Inverse of TEST.match()
                                  #Aliases: TEST.[is]dissimilar|unsimilar|[is]notSimilar|[is]unlike|[is]notLike|doesNotHave()

TEST.match(VAL, TYPE)             #instanceof TYPE (can use String|Boolean|... for simple types)
TEST.type                         #typeof VAL === 'TYPEOF' || instanceof TYPE|'TYPE'
 (VAL, 'TYPEOF'|'TYPE'|TYPE)      #Aliases: TEST.isA()

TEST.match(STR, REGEXP)           #REGEXP.test()
TEST.match(STR, STR2)             #STR.includes(STR2)


TEST.throws(FUNC[, VAL])          #FUNC() throws, and TEST.match(ERROR, VAL)
                                  #Check detail of this ???
                                  #Aliases: TEST.throw()
TEST.doesNotThrow(FUNC[, VAL])    #Inverse
                                  #Aliases: TEST.notThrow()

TEST.rejects(PROMISE[()][, VAL])  #PROMISE rejected with VAL2, and TEST.match(VAL2, VAL)
TEST.resolveMatch
 (PROMISE[()][, VAL])             #PROMISE resolved with VAL2, and TEST.match(VAL2, VAL)
TEST.resolves(PROMISE[()])        #PROMISE resolved
TEST.rejects|resolve*()           #Actually create a sub-TEST, i.e. behave like TEST.test()

Test.prototype.addAssert('FUNC', NUM, FUNC(ARGS..., 'ASSERT_TITLE', OBJ)->BOOL)
                                  #Custom assertion
                                  #NUM is ARGS length


./tap-snapshots/FILE-TAP.test.js  #Snapshot files
                                  #Are module.exports['FILE TAP > NAME NUM'] = STR
ENVVAR TAP_SNAPSHOT=1             #Write snapshots
TEST.matchSnapshot(VAL, 'NAME')   #Asserts against snapshot
                                  #VAL is stringified using UTIL.inspect()
