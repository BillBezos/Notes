
            
   NODE_TAP  
            



VERSION ==>                       #12.0.1

CONFIG ==>                        #Can be:
                                  #  - ENVVAR TAP_RCFILE YAML_FILE
                                  #  - tap --rcfile YAML_FILE
                                  #  - ~/.taprc YAML_FILE
                                  #  - tap --FLAG
                                  #Can be created from tap ... --dump-config

tap [FILE...]                     #FILE can be - (for stdin, def)

--test-arg=ARG                    #Pass CLI argument to each node FILE ...
                                  #Can be done several times

--node-arg=FLAG                   #Pass node --FLAG
                                  #Can be done several times
--[expose-]gc
--debug[-brk]
--harmony
--strict                          #Same for those FLAGs

--[no-]cov[erage]                 #Uses nyc ...
--[no-]coverage-report=FORMAT     #Def: 'text'
--no-browser                      #Unless set, --coverage-report=html will open browser afterwards
--nyc-arg=ARG                     #Pass CLI argument to nyc ...
                                  #Can be done several times
--check-coverage                  #
--branches|functions|lines|
 statements NUM                   #Specific nyc arguments
--100                             #Same as --branches|functions|lines|statements 100

--color|c
--no-color|C
ENVVAR TAP_COLORS=0|1             #

--output|o FILE                   #Def: stdout
--reporter|R FORMAT               #Pipe TAP output to reporter among any supported by tap-mocha-reporter (see its doc), or 'tap' (as is)
                                  #Def: 'classic' if colors, 'tap' otherwise
ENVVAR TAP=1                      #Ignore --reporter

--save|s FILE                     #FILE is a newline-separated list of FILE2... to run
                                  #If some tests fail, it will written to FILE, i.e. next run will only re-test failed tests.

CHECK CHILD TAP OUTPUT WORKS WITH PARSERS AND REPORTERS???

PROCESS EXIT ==>                  #On process 'exit' event:
                                  #  - make tests still running fail
                                  #  - exit code 1 if one assertion failed, or if STREAM 'error' event

TAP                               #Is also a TEST, with few exceptions documented below

TEST                              #Is an ISTREAM, piped to their parent
                                  #TAP is piped to stdout

TEST.test(['TEST_TITLE', ][TOPTS,]#Define a test
 [FUNC(TEST2)])->PROMISE_TEST     #Def 'TEST_TITLE': FUNC.name, or ''
                                  #If no FUNC: like TOPTS.todo true
TEST.end()                        #Automatically done when test's FUNC() return a PROMISE
TEST.plan(NUM[, 'COMMENT'])       #Automatically calls TEST.end() after NUM assertions
                                  #Make test fail if wrong assertions count
TEST|TOPTS.autoend                #BOOL. Automatically call TEST.end() on next microtask
                                  #Def: false except on TAP when TAP.tearDown() is defined
TEST.endAll()                     #Call TEST.end() on all children then itself

mocha.describe|context(...)       #Same as TEST.test(...) except using FUNC() (TEST is not available)
mocha.it(...)                     #Same as TEST.test(...) except using FUNC([FUNC2]) with TEST as `this`
mocha.before|after(...)           #
mocha.beforeEach|afterEach(...)   #
mochaGlobals()                    #Assign mocha.* to global.*

--timeout|t NUM
--no-timeout|T
TOPTS.timeout NUM                 #In seconds. Def: 30
ENVVAR TAP_TIMEOUT NUM            #0 to disable

--bail|b
--no-bail|B
ENVVAR TAP_BAIL=0|1
TOPTS.bail                        #BOOL (def: false): stop all tests on first test failure
TEST.bailout(['COMMENT'])         #Stops all tests

TEST.tearDown(FUNC())             #Called after TEST.end()
TEST.beforeEach|afterEach         #Called before|after each child
 (FUNC([FUNC2]))                  #Must be async: FUNC2([ERROR]) or return PROMISE

TOPTS.buffered                    #BOOL (def: TOPS.jobs > 1): whether TAP child is buffered or not (see TAP format doc)
ENVVAR TAP_BUFFER=0|1             #Must be true if TOP.jobs > 1

TEST RUN ==>                      #Test functions are run as they are defined (i.e. synchronously)
                                  #Tests are performed serially, i.e. each test wait for previous one to end.

--jobs|j NUM                      #I/O parallelism:
TEST|TOPTS.jobs NUM               #  - run test children in parallel, with maximum NUM tests running at once
                                  #CPU parallelism:
                                  #  - run test files in parallel, in different processes, with maximum NUM processes at once
                                  #  - if an empty file named 'test-parallel-[not-]ok' exists, use it to enable|disable
                                  #    parallelism on all sibling files recursively
                                  #Tests are executed out of order, but are buffered so they remain in order in the output
--jobs-auto|J                     #Same as --jobs NUMBER_OF_CPUS

TEST.spawn(..., 'TEST_TITLE')     #Uses CHILD_PROCESS.spawn(...) as TAP input for this TEST
 ->PROMISE_TEST                   #Can specify TOPTS.* in spawn() OPTS

TEST.stdin()->PROMISE_TEST        #Use stdin as TAP input for this TEST, with 'ASSERT_TITLE' '/dev/stdin'

TEST.todo(...)
TOPTS|AOPTS.todo BOOL             #Pending test

TEST.skip(...)
TOPTS|AOPTS.skip BOOL             #Skipped test

--grep|g REGEXP
TEST|TOPTS.grep REGEXP_ARR
ENVVAR TAP_GREP 'REGEXP\n...'     #Only include tests with matching title

--invert|i
ENVVAR TAP_GREP_INVERT 1|0        #Inverts --grep

TEST|TOPS.runOnly BOOL            #Def: false. For children, not recursively.
                                  #See TEST.only()
--only|O
TAP_ONLY 1|0                      #Same as setting TAP.runOnly BOOL
TEST.only(...)                    #Only run that test
TEST|TOPTS.only BOOL              #Noop if direct parent TEST.runOnly false

TEST.comment(STR)                 #TAP comment

TEST.pragma({ VAR: BOOL, ... })   #TAP pragma
                                  #Including pragma strict (see TAP-PARSER doc)

REPORTING ==>                     #Tap output (see TAP format for details)
                                  #However:
                                  #  - TAP output is not great quality, because it outputs things that most libraries don't
                                  #    handle well:
                                  #     - nested tests
                                  #     - nested plans
                                  #     - duration directives|comments
                                  #     - '- ' prepended to all 'ASSERT_TITLE'
                                  #     - non-standard|varied YAML error properties
                                  #     - no final # tests|pass|fail|ok
                                  #  - i.e. should only use --reporter option.

TAP OUTPUT ==>                    #  (beginning)
                                  #  - TAP version 13
                                  #  (each assertion)
                                  #  - '- ' prepended to all 'ASSERT_TITLE'
                                  #  - uses nested tests (see problems with them above), either:
                                  #     - buffered
                                  #     - not buffered:
                                  #        - use # Subtest: PARENT_TEST_TITLE
                                  #  - plan 1..NUM [# COMMENT]
                                  #     - at beginning if TEST.plan(), automatically added at end otherwise
                                  #  - YAML error properties:
                                  #     - at|stack STR
                                  #     - source STR
                                  #     - found|wanted|doNotWant|pattern|error|type VAL
                                  #     - compare '===|!=='
                                  #  - DIRECTIVE # time=NUMms, providing it has children
                                  #  (TEST.only|skip(), grep)
                                  #  - directive # SKIP filter: /REGEXP/ (or only)
                                  #  - comment # skip: NUM at end of parent
                                  #  (TEST.todo())
                                  #  - directive # TODO
                                  #  (TEST.comment())
                                  #  - # COMMENT
                                  #  (TEST.bailout())
                                  #  - Bail out! [COMMENT]
                                  #  (TEST.pragma())
                                  #  - pragma
                                  #  (end)
                                  #  - comment # time=NUMms

DURATION ==>                      #Tests each|total duration added to TAP output (see TAP format doc for details)

TAP'S YAML ERROR PROPERTIES ==>   #  - at STR, stack STR: using (new Error).stack
                                  #  - source STR: source line of code
                                  #  - found VAL: with TEST.equal|notEqual|strictSame|strictNotSame|same|notSame|error|match|notMatch|type|snapshot()
                                  #  - wanted VAL2: with TEST.equal|strictSame|same|type|snapshot()
                                  #  - doNotWant VAL2: with TEST.notEqual|strictNotSame|notSame()
                                  #  - pattern VAL2: with TEST.match|notMatch()
                                  #  - error ERROR: with TEST.doesNotThrow()
                                  #  - type ERROR_TYPE: with TEST.doesNotReject
                                  #  - compare STR: '===' for TEST.equal|type|snapshot(), '!==' for TEST.notEqual()
TOPTS|AOPTS.diagnostic BOOL
ENVVAR TAP_DIAG=0|1               #Set YAML error properties even if assertion passes

EXCEPTIONS ==>                    #Assertions only report: they do not throw (i.e. control flow continues)

TEST.*()->BOOL                    #All assertions return BOOL (or PROMISE for TEST.resolve*|rejects())
TEST.passing()->BOOL              #False if a previous assertion has failed

EXCEPTION HANDLING ==>            #Thrown exceptions make test fail using TEST.threw(), but are not propagated
                                  #They throw a deprecation warning from Node.js (because they use DOMAINs)

TEST.*                            #Can be passed for all assertion functions
 (...[, 'ASSERT_TITLE'][, AOPTS]) #Def 'ASSERT_TITLE':
                                  #  - TEST.pass|fail|skip(): '(unnamed test)'
                                  #  - TEST.threw|error(): ERROR.message
                                  #  - TEST.throws|doesNotThrow|rejects|resolve*(): FUNC.name
                                  #  - custom assertion: none
                                  #  - others: 'should|expect ...'

TEST.pass()                       #
TEST.fail()                       #

TEST.threw(ERROR)                 #Like TEST.fail() but using information from ERROR:
                                  #  - 'ASSERT_TITLE': ERROR.message
                                  #  - stack|at|source: ERROR.stack
                                  #  - any ERROR.*: as is (stringified with UTIL.inspect())

TEST.equal(VAL, VAL2)             #===
                                  #Aliases: TEST.equals|isEqual|is|strictEqual[s]|strictIs|isStrict[ly]()
TEST.notEqual(VAL, VAL2)          #!==
                                  #Aliases: TEST.notEquals|isNotEqual|doesNotEqual|[is]inequal|isNot|notStrictEqual[s]()
TEST.strictSame(VAL, VAL2)        #Deep ===
                                  #Aliases: TEST.strictDeepEqual[s]|strictEquivalent|sameStrict|deepIs|isDeep[ly]()
TEST.strictNotSame(VAL, VAL2)     #Deep !==
                                  #Aliases: TEST.strictInequivalent|strictDeepInequal[s]|notSameStrict|deepNot|notDeeply|notStrictSame()
TEST.same(VAL, VAL2)              #Deep ==
                                  #Aliases: TEST.deepEqual[s]|looseEqual[s]|equivalent|isLoose|looseIs()
TEST.notSame(VAL, VAL2)           #Deep !=
                                  #Aliases: TEST.notLoose|looseNot|notDeep|inequivalent|looseInequal|deepInequal()

TEST.error(ERROR)                 #instanceof Error
                                  #Aliases: TEST.ifErr[or]()

TEST.ok(VAL)                      #== true
                                  #Aliases: TEST.true|assert()
TEST.notOk(VAL)                   #== false
                                  #Aliases: TEST.false|assertNot()

TEST.match(VAL, VAL2)             #Deep ==
                                  #Aliases: TEST.has[Fields]|matches|similar|[is]like|include[s]|contains()
TEST.match(OBJ, OBJ2)             #Deep TEST.match()
TEST.notMatch(VAL, VAL2)          #Inverse of TEST.match()
                                  #Aliases: TEST.[is]dissimilar|unsimilar|[is]notSimilar|[is]unlike|[is]notLike|doesNotHave()

TEST.match(VAL, TYPE)             #instanceof TYPE (can use String|Boolean|... for simple types)
TEST.type                         #typeof VAL === 'TYPEOF' || instanceof TYPE|'TYPE'
 (VAL, 'TYPEOF'|'TYPE'|TYPE)      #Aliases: TEST.isA()

TEST.match(STR, REGEXP)           #REGEXP.test()
TEST.match(STR, STR2)             #STR.includes(STR2)


TEST.throws(FUNC[, VAL])          #FUNC() throws, and TEST.match(ERROR, VAL)
                                  #Aliases: TEST.throw()
TEST.doesNotThrow(FUNC[, VAL])    #Inverse
                                  #Aliases: TEST.notThrow()

TEST.rejects(PROMISE[()][, VAL])  #PROMISE rejected with VAL2, and TEST.match(VAL2, VAL)
TEST.resolveMatch
 (PROMISE[()][, VAL])             #PROMISE resolved with VAL2, and TEST.match(VAL2, VAL)
TEST.resolves(PROMISE[()])        #PROMISE resolved
TEST.rejects|resolve*()           #Actually create a sub-TEST, i.e. behave like TEST.test()

Test.prototype.addAssert
 ('FUNC', NUM,
 FUNC(ARGS..., 'ASSERT_TITLE',OBJ)#Custom assertion
 ->BOOL)                          #NUM is ARGS length


./tap-snapshots/FILE-TAP.test.js  #Snapshot files
                                  #Are module.exports['FILE TAP > NAME NUM'] = STR
ENVVAR TAP_SNAPSHOT=1             #Write snapshots
TEST.matchSnapshot(VAL, 'NAME')   #Asserts against snapshot
                                  #VAL is stringified using UTIL.inspect()
