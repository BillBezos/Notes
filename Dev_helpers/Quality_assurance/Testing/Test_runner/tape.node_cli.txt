
        
   TAPE  
        



VERSION ==>                       #4.9.0
                                  #Node, browser and CLI


TAPE.*                            #Default way of initializing
TAPE.getHarness([HOPTS])->TAPE    #Alternative way of initializing
                                  #Specifies HOPTS for all TAPE.*() calls
                                  #TAPE return value is same reference (must be done before any TAPE.*() calls)
TAPE.createHarness([COPTS])->TAPE2#Alternative way of initializing
                                  #Specifies COPTS for all TAPE2.*() calls
                                  #TAPE2 return value is different reference from TAPE


STREAMING ==>                     #By default, TAP output is piped to stdout unless either:
                                  #  - HOPTS.stream STREAM: piped to STREAM
                                  #  - initialized with TAPE.createHarness()->TAPE2: piped to TAPE2.createStream()
TAPE.createStream([OPTS])->ISTREAM#Read TAP output
                                  #OPTS|HOPTS.objectMode BOOL (def: false):
                                  #  - instead of STR lines, get stream of OBJ:
                                  #     - type 'test', name 'TEST_TITLE', id TEST_ID, parent TEST_ID
                                  #     - type 'assert', name 'ASSERT_TITLE', operator STR, test TEST_ID, skip BOOL, actual|expected VAL,
                                  #       error ERROR, functionName 'FUNC', file STR, line NUM, at STR
                                  #     - type 'end', test TEST_ID


EXIT EVENT HANDLING ==>           #On process 'exit' event:
                                  #  - create assertion failure if some tests are still running
                                  #  - exit code 1 if either:
                                  #     - one assertion failed
                                  #     - STREAM 'error' event
                                  #Not done if either:
                                  #  - HOPTS.exit false
                                  #  - initialized with TAPE.createHarness()



TAP OUTPUT ==>                    #  (beginning)
                                  #  - TAP version 13
                                  #  (TAPE.test())
                                  #  - # TEST_TITLE
                                  #  (TEST.skip())
                                  #  - # SKIP TEST_TITLE ???
                                  #  (assertions)
                                  #  - [not] ok INDEX ASSERT_TITLE [# SKIP]
                                  #  - YAML error props: operator, expected|actual, at|stack
                                  #  (TEST.comment())
                                  #  - # COMMENT
                                  #  (TEST.plan())
                                  #  - plan 1..NUM end
                                  #  (end)
                                  #  - # tests|pass|fail NUM
                                  #  - # ok


TAPE.test(['TEST_TITLE', ]        #Define a test
 [TOPTS, ]FUNC(TEST))             #Def 'TEST_TITLE': '(anonymous)'
                                  #Can specify different default TOPTS with COPTS.*
TEST.end([ERROR])                 #Must be called
TEST.plan(NUM)                    #Automatically calls TEST.end() after NUM assertions
                                  #Assertion failure if plan does not match assertion count

TEST.test(...)                    #Like TAPE.test(...) but for a sub-TEST (i.e. like describe())

TEST RUN ==>                      #Tests are run:
                                  #  - on next microtask after first test is defined
                                  #  - serially, waiting for each TEST.end()
                                  #     - sub-TEST must end as well
                                  #  - when all tests are run, closes stream

TAPE.close()                      #Add final TAP output (plan and # tests|pass|fail|ok)
                                  #Done automatically once all tests have run, unless COPTS.autoclose false

TOPTS.skip                        #BOOL (def: false)
TAPE.skip(...)                    #Same as TAPE.test() but with TOPTS.skip true
TEST.skip([STR])                  #

TAPE.only(...)                    #Same as TAPE.test() but only run that test

TOPTS.timeout                     #NUM (def: 500)
TEST.timeoutAfter(NUM)            #Assertion failure after NUMms

TEST.comment(STR)                 #TAP comment

TAPE.onFinish(FUNC())             #afterAll() hook
TAPE.onFailure(FUNC())            #Each time a test fails



TEST.*(...[, 'ASSERT_TITLE'])     #All assertions can specify ASSERT_TITLE as last argument. Def:
                                  #  - TEST.fail|pass|skip(): '(unnamed assert)'
                                  #  - TEST.error(): ERROR.message
                                  #  - others: 'should be ...'
YAML ERROR PROPS ==>              #Are:
                                  #  - operator 'FUNC_NAME'
                                  #  - expected|actual VAL: on all but TEST.fail|pass()
                                  #  - at STR, stack STR from either:
                                  #     - thrown ERROR by TEST.throws|doesNotThrow()
                                  #     - (new Error).stack

TOPTS.objectPrintDepth            #NUM (def: 5)
                                  #When stringifying assertions' expected|actual VAL
NODE_TAPE_OBJECT_PRINT_DEPTH      #Same as ENVVAR

TEST.fail()                       #
TEST.pass()                       #
TEST.ok(VAL)                      #== true
                                  #Aliases: TEST.true|assert()
TEST.notOk(VAL)                   #== false
                                  #Aliases: TEST.false()
TEST.error(ERROR)                 #== false (i.e. undefined)
                                  #Uses ERROR.message
                                  #Aliases: TEST.ifErr[or]()
TEST.equal(VAL, VAL2)             #===
                                  #Aliases: TEST.equals|isEqual|is|strictEqual[s]()
TEST.notEqual(VAL, VAL2)          #!==
                                  #Aliases: TEST.notEquals|isNotEqual|doesNotEqual|isInequal|isNot|not|notStrictEqual[s]()
TEST.deepEqual(VAL, VAL2)         #Deep ===
                                  #Aliases: TEST.deepEquals|isEquivalent|same()
TEST.notDeepEqual(VAL, VAL2)      #Deep !==
                                  #Aliases: TEST.[is]notEquivalent|[is]notDeeply|notSame|isNotDeepEqual|isInequivalent()
TEST.deepLooseEqual               #Deep ==
 (VAL, VAL2)                      #Aliases: TEST.looseEqual[s]()
TEST.notDeepLooseEqual            #Deep !=
 (VAL, VAL2)                      #Aliases: TEST.notLooseEqual[s]()
TEST.throws                       #FUNC() throws
 (FUNC[, REGEXP|TYPE])            #ERROR.message matches REGEXP or ERROR instanceof TYPE
TEST.doesNotThrow
 (FUNC[, REGEXP|TYPE])            #FUNC() does not throw
