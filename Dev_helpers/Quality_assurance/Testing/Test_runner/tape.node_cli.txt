
        
   TAPE  
        



VERSION ==>                       #4.9.0
                                  #Node, browser and CLI


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONFIG             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TAPE.getHarness([HOPTS])->TAPE    #Optional initialization, specifying HOPTS for all TAPE.*() calls
                                  #TAPE return value is same reference (must be done before any TAPE.*() calls)
TAPE.createHarness([COPTS])->TAPE2#Optional initialization, specifying COPTS for all TAPE2.*() calls
                                  #TAPE2 return value is different reference from TAPE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OUTPUT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TAP OUTPUT ==>                    #See TAP format doc for details

STREAMING ==>                     #TAP output is piped to either:
                                  #  - stdout
                                  #     - def unless initialized with TAPE.createHarness()
                                  #  - HOPTS.stream ISTREAM
                                  #  - TAPE.createStream([SOPTS])->ISTREAM
                                  #     - must be called before any TAPE.*() calls
HOPTS|SOPTS.objectMode            #BOOL (def: false)
                                  #Instead of STR lines, get stream of OBJ:
                                  #  - type 'test', name 'TEST_TITLE', id TEST_ID, parent TEST_ID
                                  #  - type 'assert', name 'ASSERT_TITLE', ok BOOL, id INDEX, operator STR, test TEST_ID, skip BOOL, actual|expected VAL,
                                  #    error ERROR, functionName 'FUNC', file STR, line|column NUM, at STR, objectPrintDepth NUM
                                  #  - 'COMMENT'
                                  #  - type 'end', test TEST_ID (end of each TEST)
                                  #  - null (end of all TESTs)

TAPE.close()                      #Closes stream, adding final TAP output (plan and # tests|pass|fail|ok)
                                  #Done automatically once all tests have run, unless COPTS.autoclose false
                                  #Only available when initialized using TAPE.getHarness|createHarness()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              RUN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST RUN ==>                      #Tests are run:
                                  #  - after first test is defined, on next microtask
                                  #  - serially, waiting for each TEST.end()
                                  #     - sub-TESTs must end as well
                                  #  - when all tests are run, closes stream (writing final TAP output)

PROCESS EXIT ==>                  #On process 'exit' event:
                                  #  - make tests still running fail
                                  #  - exit code 1 if one assertion failed, or if STREAM 'error' event
                                  #Not done if either:
                                  #  - HOPTS.exit false
                                  #  - initialized with TAPE.createHarness()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TESTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TAPE.test(['TEST_TITLE', ]        #Define a test
 [TOPTS, ]FUNC(TEST))             #Def 'TEST_TITLE': '(anonymous)'
                                  #Can specify different default TOPTS with COPTS.*
TEST.end([ERROR])                 #Must be called (otherwise will hang)
TEST.plan(NUM)                    #Automatically calls TEST.end() after NUM assertions
                                  #Assertion failure if plan does not match assertion count

TEST.test(...)                    #Like TAPE.test(...) but for a sub-TEST (i.e. like describe())

TOPTS.skip                        #BOOL (def: false)
TAPE.skip(...)                    #Same arguments as TAPE.test(...)
TEST.skip(['ASSERT_TITLE'])       #

TAPE.only(...)                    #Same as TAPE.test(...) but only run that test

TOPTS.timeout                     #NUM (def: 500)
TEST.timeoutAfter(NUM)            #Assertion failure after NUMms

TAPE.onFinish(FUNC())             #afterAll() hook
TAPE.onFailure(FUNC())            #Each time a test fails

TEST.comment(STR)                 #TAP comment



TEST.*(...[, 'ASSERT_TITLE'])     #All assertions can specify ASSERT_TITLE as last argument. Def:
                                  #  - TEST.fail|pass|skip(): '(unnamed assert)'
                                  #  - TEST.error(): ERROR.message
                                  #  - others: 'should be ...'
TAP'S YAML ERROR PROPS ==>        #Are:
                                  #  - operator 'FUNC_NAME'
                                  #  - expected|actual VAL: on all but TEST.fail|pass()
                                  #  - at STR, stack STR from either:
                                  #     - thrown ERROR by TEST.throws|doesNotThrow()
                                  #     - (new Error).stack

TOPTS.objectPrintDepth            #NUM (def: 5)
                                  #When stringifying assertions' expected|actual VAL
NODE_TAPE_OBJECT_PRINT_DEPTH      #Same as ENVVAR

TEST.fail()                       #
TEST.pass()                       #

TEST.ok(VAL)                      #== true
                                  #Aliases: TEST.true|assert()
TEST.notOk(VAL)                   #== false
                                  #Aliases: TEST.false()
TEST.error(ERROR)                 #== false (i.e. undefined)
                                  #Uses ERROR.message
                                  #Aliases: TEST.ifErr[or]()

TEST.equal(VAL, VAL2)             #===
                                  #Aliases: TEST.equals|isEqual|is|strictEqual[s]()
TEST.notEqual(VAL, VAL2)          #!==
                                  #Aliases: TEST.notEquals|isNotEqual|doesNotEqual|isInequal|isNot|not|notStrictEqual[s]()
TEST.deepEqual(VAL, VAL2)         #Deep ===
                                  #Aliases: TEST.deepEquals|isEquivalent|same()
TEST.notDeepEqual(VAL, VAL2)      #Deep !==
                                  #Aliases: TEST.[is]notEquivalent|[is]notDeeply|notSame|isNotDeepEqual|isInequivalent()
TEST.deepLooseEqual(VAL, VAL2)    #Deep ==
                                  #Aliases: TEST.looseEqual[s]()
TEST.notDeepLooseEqual(VAL, VAL2) #Deep !=
                                  #Aliases: TEST.notLooseEqual[s]()

TEST.throws(FUNC[, REGEXP|TYPE])  #FUNC() throws
                                  #ERROR.message matches REGEXP or ERROR instanceof TYPE
TEST.doesNotThrow
 (FUNC[, REGEXP|TYPE])            #FUNC() does not throw
