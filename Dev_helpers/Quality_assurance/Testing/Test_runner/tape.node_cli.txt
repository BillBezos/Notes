
        
   TAPE  
        



VERSION ==>                       #4.9.0
                                  #Node, browser and CLI


TAPE.*                            #Default way of initializing
TAPE.getHarness([HOPTS])->TAPE    #Alternative way of initializing
                                  #Specifies HOPTS for all TAPE.*() calls
                                  #TAPE return value is same reference (must be done before any TAPE.*() calls)
TAPE.createHarness([COPTS])->TAPE2#Alternative way of initializing
                                  #Specifies COPTS for all TAPE2.*() calls
                                  #TAPE2 return value is different reference from TAPE


STREAMING ==>                     #By default, TAP output is piped to stdout unless either:
                                  #  - HOPTS.stream STREAM: piped to STREAM
                                  #  - initialized with TAPE.createHarness()->TAPE2: piped to TAPE2.createStream()
TAPE.createStream([OPTS])->ISTREAM#Read TAP output
                                  #OPTS|HOPTS.objectMode BOOL (def: false):
                                  #  - instead of STR lines, get stream of OBJ:
                                  #     - type 'test', name 'TEST_TITLE', id TEST_ID, parent TEST_ID
                                  #     - type 'assert', name 'ASSERT_TITLE', operator STR, test TEST_ID, skip BOOL, actual|expected VAL,
                                  #       error ERROR, functionName 'FUNC', file STR, line NUM, at STR
                                  #     - type 'end', test TEST_ID


EXIT EVENT HANDLING ==>           #On process 'exit' event:
                                  #  - create assertion failure if some tests are still running
                                  #  - exit code 1 if either:
                                  #     - one assertion failed
                                  #     - STREAM 'error' event
                                  #Not done if either:
                                  #  - HOPTS.exit false
                                  #  - initialized with TAPE.createHarness()



RESULTS.push(TEST):
  - on TEST prerun: # TEST_TITLE
  - on TEST result COMMENT: # COMMENT
  - on TEST result { ok, name, skip, todo, operator, expected, actual, at, error }:
     - [not] ok INDEX ASSERT_TITLE [# SKIP]
  - on beginning: TAP version 13
  - at end:
     - plan 1..NUM
     - # tests|pass|fail NUM
     - # ok
  - fires each TEST.run() serially, asynchronously await them

TAPE.close()                      #Add final TAP output (plan and # tests|pass|fail|ok)
                                  #Done automatically once all tests have run, unless COPTS.autoclose false

TEST:
  - TAPE.test('TEST_TITLE')
  - TEST.skip() -> # SKIP TEST_TITLE
  - assertions functions:
     - [not] ok INDEX ASSERT_TITLE [# SKIP]
        - ASSERT_TITLE:
           - STR argument of test assertions
           - def:
              - TEST.fail|pass|skip(): '(unnamed assert)'
              - TEST.error(): ERROR.message
              - others: 'should be ...'
        - SKIP if TEST OPTS.skip true or TEST.skip()
     - YAML error props:
        - operator 'fail|pass|skip|ok|notOk|error|equal|notEqual|deep[Loose]Equal||notDeep[Loose]Equal|throws'
        - expected|actual VAL:
           - stringified with UTIL.inspect() and OPTS.objectPrintDepth
           - when using any assertion except TEST.fail|pass()
        - at STR, stack STR: from (new Error).stack or ERROR thrown by TEST.throws|doesNotThrow()
  - TEST.plan():
     - plan 1..NUM at end
     - add assertion failure if plan does not match assertion count on a specific test
  - TEST.comment('COMMENT'): # COMMENT
  - TEST.timeoutAfter(): assertion failure after timeout
  - loop:
     - starts after first test is define
     - run each test serially, waiting for TAPE.end() to be called or number of assertions from TEST.plan() to be called
     - when done, closes


TAPE.test                         #Define a test
 (['TITLE', ][OPTS, ]FUNC(TEST))  #Def 'TITLE': '(anonymous)'
                                  #OPTS:
                                  #  - skip BOOL (def: false)
                                  #  - timeout NUM (def: 500)
                                  #  - objectPrintDepth NUM (def: 5): can also use ENVVAR NODE_TAPE_OBJECT_PRINT_DEPTH
                                  #Can specify different default OPTS with COPTS.*
TEST.end([ERROR])                 #Must either be called, or TEST.plan() must be defined
                                  #Tests are run serially, i.e. this will start the next TEST
TEST.plan(NUM)                    #

TEST.test(...)                    #Like TAPE.test(...) but for a sub-test (i.e. like describe())

TAPE.skip(...)                    #Same as TAPE.test() but with OPTS.skip true
TAPE.only(...)                    #Same as TAPE.test() but only run that test

TEST.skip([STR])                  #
TEST.timeoutAfter(NUM)            #

TEST.comment(STR)                 #TAP comment

TAPE.onFinish(FUNC())             #afterAll() hook
TAPE.onFailure(FUNC())            #Each time a test fails

TEST.fail('ERROR')                #
TEST.pass([STR])                  #
TEST.ok(VAL[, STR])               #== true
                                  #Aliases: TEST.true|assert()
TEST.notOk(VAL[, STR])            #== false
                                  #Aliases: TEST.false()
TEST.error(ERROR[, STR])          #== false (i.e. undefined)
                                  #Uses ERROR.message
                                  #Aliases: TEST.ifErr[or]()
TEST.equal(VAL, VAL2[, STR])      #===
                                  #Aliases: TEST.equals|isEqual|is|strictEqual[s]()
TEST.notEqual(VAL, VAL2[, STR])   #!==
                                  #Aliases: TEST.notEquals|isNotEqual|doesNotEqual|isInequal|isNot|not|notStrictEqual[s]()
TEST.deepEqual(VAL, VAL2[, STR])  #Deep members ===
                                  #Aliases: TEST.deepEquals|isEquivalent|same()
TEST.notDeepEqual(VAL, VAL2[,STR])#Deep members !==
                                  #Aliases: TEST.[is]notEquivalent|[is]notDeeply|notSame|isNotDeepEqual|isInequivalent()
TEST.deepLooseEqual               #Deep members ==
 (VAL, VAL2[, STR])               #Aliases: TEST.looseEqual[s]()
TEST.notDeepLooseEqual            #Deep members !=
 (VAL, VAL2[, STR])               #Aliases: TEST.notLooseEqual[s]()
TEST.throws                       #FUNC() throws
 (FUNC[, REGEXP|TYPE][, STR])     #ERROR.message matches REGEXP or ERROR instanceof TYPE
TEST.doesNotThrow
 (FUNC[, REGEXP|TYPE][, STR])     #FUNC() does not throw




