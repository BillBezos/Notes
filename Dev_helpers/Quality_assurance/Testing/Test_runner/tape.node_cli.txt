
        
   TAPE  
        



VERSION ==>                       #4.9.0
                                  #Node, browser and CLI


TAPE.*                            #Default way of initializing
TAPE.getHarness([HOPTS])->TAPE    #Alternative way of initializing
                                  #Specifies HOPTS for all TAPE.*() calls
                                  #TAPE return value is same reference (must be done before any TAPE.*() calls)
TAPE.createHarness([COPTS])->TAPE2#Alternative way of initializing
                                  #Specifies COPTS for all TAPE2.*() calls
                                  #TAPE2 return value is different reference from TAPE


STREAMING ==>                     #By default, TAP output is piped to stdout unless either:
                                  #  - HOPTS.stream STREAM: piped to STREAM
                                  #  - initialized with TAPE.createHarness()->TAPE2: piped to TAPE2.createStream()
TAPE.createStream([OPTS])->ISTREAM#Read TAP output
                                  #OPTS|HOPTS.objectMode BOOL (def: false):
                                  #  - instead of STR lines, get stream of OBJ:
                                  #     - type 'test', name 'TEST_TITLE', id TEST_ID, parent TEST_ID
                                  #     - type 'assert', name 'ASSERT_TITLE', test TEST_ID, actual|expected VAL,
                                  #       error ERROR, functionName 'FUNC', file STR, line NUM, at STR
                                  #     - type 'end', test TEST_ID


EXIT EVENT HANDLING ==>           #On process 'exit' event:
                                  #  - create assertion failure if either:
                                  #     - some tests are still running
                                  #     - plan did not match assertion count
                                  #  - exit code 1 if either:
                                  #     - one assertion failed
                                  #     - STREAM 'error' event
                                  #Not done if either:
                                  #  - HOPTS.exit false
                                  #  - initialized with TAPE.createHarness()



RESULTS.push(TEST):
  - on TEST prerun: # TEST_TITLE
  - on TEST result COMMENT: # COMMENT
  - on TEST result { ok, name, skip, todo, operator, expected, actual, at, error }:
     - [not] ok INDEX ASSERT_TITLE [# SKIP|TODO]
     - YAML error props:
        - operator STR
        - expected|actual VAL: stringified with UTIL.inspect() and OPTS.objectPrintDepth
        - at STR
        - stack STR: ERROR.stack from either actual ERROR or error ERROR
  - on beginning: TAP version 13
  - at end:
     - plan 1..NUM
     - # tests|pass|fail NUM
     - # ok
  - fires each TEST.run() serially, asynchronously await them

TAPE.close()                      #Add final TAP output (plan and # tests|pass|fail|ok)
                                  #Done automatically once all tests have run, unless COPTS.autoclose false

TEST:
  - events:
     - 'prerun': start of test
     - 'test': subtest
     - 'result': assertion
     - 'end': TEST.end()
  - TEST.skip() -> # SKIP TEST_TITLE
  - TEST._assert(BOOL, OPTS):
     -
  - new Test(...): define
  - run(): run


TAPE.test                         #Define a test
 (['TITLE', ][OPTS, ]FUNC(TEST))  #Def 'TITLE': '(anonymous)'
                                  #OPTS:
                                  #  - skip BOOL (def: false)
                                  #  - timeout NUM (def: 500)
                                  #  - objectPrintDepth NUM (def: 5): can also use ENVVAR NODE_TAPE_OBJECT_PRINT_DEPTH
                                  #Can specify different default OPTS with COPTS.*
TEST.end([ERROR])                 #Must either be called, or TEST.plan() must be defined
                                  #Tests are run serially, i.e. this will start the next TEST
TEST.plan(NUM)                    #

TEST.test(...)                    #Like TAPE.test(...) but for a sub-test (i.e. like describe())

TAPE.skip(...)                    #Same as TAPE.test() but with OPTS.skip true
TAPE.only(...)                    #Same as TAPE.test() but only run that test

TEST.skip([STR])                  #
TEST.timeoutAfter(NUM)            #

TEST.comment(STR)                 #TAP comment

TAPE.onFinish(FUNC())             #afterAll() hook
TAPE.onFailure(FUNC())            #Each time a test fails

TEST.fail('ERROR')                #
TEST.pass([STR])                  #
TEST.ok(VAL[, STR])               #== true
                                  #Aliases: TEST.true|assert()
TEST.notOk(VAL[, STR])            #== false
                                  #Aliases: TEST.false()
TEST.error(ERROR[, STR])          #== false (i.e. undefined)
                                  #Uses ERROR.message
                                  #Aliases: TEST.ifErr[or]()
TEST.equal(VAL, VAL2[, STR])      #===
                                  #Aliases: TEST.equals|isEqual|is|strictEqual[s]()
TEST.notEqual(VAL, VAL2[, STR])   #!==
                                  #Aliases: TEST.notEquals|isNotEqual|doesNotEqual|isInequal|isNot|not|notStrictEqual[s]()
TEST.deepEqual(VAL, VAL2[, STR])  #Deep members ===
                                  #Aliases: TEST.deepEquals|isEquivalent|same()
TEST.notDeepEqual(VAL, VAL2[,STR])#Deep members !==
                                  #Aliases: TEST.[is]notEquivalent|[is]notDeeply|notSame|isNotDeepEqual|isInequivalent()
TEST.deepLooseEqual               #Deep members ==
 (VAL, VAL2[, STR])               #Aliases: TEST.looseEqual[s]()
TEST.notDeepLooseEqual            #Deep members !=
 (VAL, VAL2[, STR])               #Aliases: TEST.notLooseEqual[s]()
TEST.throws                       #FUNC() throws
 (FUNC[, REGEXP|FUNC2][, STR])    #ERROR.message matches REGEXP or FUNC2(ERROR)->true
TEST.doesNotThrow
 (FUNC[, REGEXP|FUNC2][, STR])    #FUNC() does not throw




